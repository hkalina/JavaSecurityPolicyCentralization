%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Jan Kalina <xkalin03@stud.fit.vutbr.cz> 2014
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Úvod} \label{uplnyUvod}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Okolo bezpečnosti serverů poskytujících své služby počítačům v síti bylo již zpracováno mnoho různých prací.
Tato práce se však nezabývá problémem, jak zabránit útoku zvenčí útočníkům v síti, ale jak předejít nebezpečí ze strany aplikací nainstalovaných na tomto serveru.
Zabývá se tedy tím, jak omezit možnosti aplikací běžících v daném systému a zabránit jim v přístupu ke zdrojům systému, na které nemají nárok.

Tato omezení mohou plnit různé účely -- od zabránění vzájemnému přístupu k datům jedné aplikace druhou aplikací jiného provozovatele,
v rámci serveru sdíleného mezi více provozovateli aplikací, po zabránění škodám na jiných aplikacích a službách v případě úspěšného prolomení
zabezpečení jedné z aplikací běžících na serveru sdíleného více aplikacemi.

Pro podobné účely se obvykle využívají oprávnění na úrovni operačního systému.
Ty však, ať už se jedná o jednoduchá unixová oprávnění, podrobnější NTFS oprávnění, či ještě podrobnější oprávnění systému SELinux,
nejsou schopny rozlišit jednotlivé aplikace běžící v rámci jediného procesu.
Takovým procesem, v rámci něhož může běžet více aplikací, je například aplikačního server WildFly.

Tento problém je možné vyřešit na úrovni virtuálního stroje Javy, uvnitř kterého aplikační server běží, za pomoci tzv. správce bezpečnosti (Security Manager)
a bezpečnostních politik (Security Policy). Ty umožňují omezovat oprávnění kódu jednotlivých tříd v Javě.
Jejich obecné použití je podrobně popsáno v kapitole \ref{teoretickyUvod}, jejich použitím v rámci aplikačního serveru WildFly se pak zabývá kapitola \ref{jboss}.

V prostředí datových center jsou aplikační servery spojovány do centrálně spravovaných distribuovaných prostředí, takzvaných domén.
V tomto prostředí se může jako velmi užitečná projevit možnost centrální správy těchto bezpečnostních politik napříč servery této domény.

Řešení umožňující centrální správu bezpečnostních politik je hlavním tématem této bakalářské práce.
Je implementováno jako rozšíření aplikačního serveru WildFly a jeho webové uživatelské rozhraní jako rozšíření webové administrační konzole WildFly.
Jeho návrh je nastíněn v kapitole \ref{navrh}, jeho implementace je popsána v kapitole \ref{implementace} a jeho testování v kapitole \ref{testovani}.

Implementace tohoto řešení byla úspěšná a výsledkem této práce je tedy rozšíření WildFly, umožňující využívat a za běhu aplikačního serveru
nastavovat soubory bezpečnostní politiky Javy.
Je tak přímo uplatnitelné ve stávajících aplikacích aplikačního serveru WildFly, kde je kladen velký důraz na bezpečnost.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Bezpečnost v Javě} \label{teoretickyUvod}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\section{Bezpečnost}
%=============================================================================

Protože se tato práce zabývá bezpečností, což je pojem, který lze v různých souvislostech chápat zcela odlišně. Je nanejvýš vhodné nejprve specifikovat co termínem bezpečnosti míníme a z jakého pohledu se jí budeme zabývat.

Scott Oaks definuje ve své knize Java Security bezpečnost jako souhrn následujících kritérií: \cite[1.1]{oaks}

\begin{itemize}
  \item {\bf Bezpečí vůči zákeřnému software} -- programy by neměly být schopny poškodit prostředí hostitelského počítače.
  \item {\bf Bezpečí vůči Velkému bratru} -- programům by mělo být bráněno ve sledování uživatele -- programy by neměly být schopny svévolně číst soukromé informace na počítači, na kterém běží, ani na síti, ke které je tento počítač připojen.
  \item {\bf Autentizace} -- identita autorů programu by měla být ověřována (typicky pomocí digitálního podpisu).
  \item Šifrování -- data odesílaná a přijímaná programem by měla být šifrována.
  \item Auditovatelnost -- potenciálně škodlivé operace by měly být vždy zaznamenávány.
  \item Specifikovanost -- program by měla doprovázet specifikace bezpečnostních pravidel, které program dodržuje.
  \item Verifikovanost -- pro prováděné operace by měla být stanovena pravidla, proti kterým by měly být verifikovány.
  \item Dbaní na dobré vychování -- programům by mělo být bráněno v užívání příliš mnoha systémových prostředků.
\end{itemize}

V souvislosti s víceuživatelskými prostředími se pak pojem bezpečnosti vyskytuje ještě v další rovině, kdy nejde o bezpečí systému před běžící aplikací, ale o způsob jakým může naopak program ověřit, kdo je jeho uživatelem a zdali má právo po něm žádat vykonání operace, o jejíž vykonání žádá. Touto stránkou bezpečnosti se však tato práce zabývat nebude.

Tato práce se zabývá bezpečností ve smyslu prvních tří bodů uvedeného výčtu (zvýrazněny tučně). Bude se tedy zabývat způsobem ochrany prostředí hostitelského počítače před jeho poškozením nebo neoprávněným sledováním ze strany běžících programů. Právě oprávnění programu pak souvisí s autentizací. Autentizací se myslí ověřování autorství programu. Právě od toho, kdo je autorem programu, se totiž mohou oprávnění programu často odvozovat.

%=============================================================================
\section{Java}
%=============================================================================

Programy v jazyce Java bývají překládány do platformě nezávislého a efektivně interpretovatelného mezikódu, takzvaného bajtkódu.
Bajtkód ({\it bytecode}) bývá zpravidla interpretován virtuálním strojem Javy (JVM - Java Virtual Machine).
\cite{jvmIntro}

JVM je abstraktní výpočetní stroj. Podobně jako reálné výpočetní stroje má svoji instrukční sadu a paměť, se kterou může manipulovat, ale na rozdíl od nich pro něj neexistuje jeho fyzická implementace, pouze emulovaná implementace softwarová.
\cite{jvmIntro}

To znamená, že její kód není prováděn nativně hardwarem. Je interpretován speciálním programem, interpretem, který je sám zkompilovaný do nativního kódu dané platformy a prováděn jejím hardwarem.
To mimo nezávislosti na platformě přináší také vyšší stupeň abstrakce.
\cite{jvmIntro}

Protože programy v JVM mohou k fyzickým zdrojům počítače (např. k souborům nebo k síti) přistupovat jen skrze JVM, zablokování takového přístupu ze strany JVM není nikterak složité - JVM stačí odmítnout takový požadavek a interpretovaný program nemá možnost JVM obejít.

%=============================================================================
\section{Správce bezpečnosti v Javě} \label{securityManager}
%=============================================================================

Pro maximální nastavitelnost omezení kladených na programy běžící ve virtuálních strojích Javy nerozhoduje o povolení nebo zablokování operace nad zdrojem JVM samotná JVM. Dotazuje se namísto toho speciálního objektu, tzv. správce bezpečnosti. \cite{tutorialsTSM}

Správce bezpečnosti je objektem třídy {\tt java.lang.SecurityManager} nebo její podtřídy.
Třídu, jejíž objekt JVM použije při svém startu jako objekt správce bezpečnosti, lze nastavit skrze konfigurační proměnnou JVM {\tt java.security.manager}. \cite{javaSecurityArch}

Aplikace může referenci na aktuálně používaný objekt správce bezpečnosti získat voláním {\tt System.getSecurityManager()} a vypnout nebo jej vyměnit voláním {\tt System.setSecu\linebreak rityManager()}. Volání těchto metod je samo chráněno správcem bezpečnosti.
Nehrozí tedy, že by se program neoprávněně zbavil omezení, která na něj správce bezpečnosti uvalil, jeho vypnutím nebo výměnou.
\cite{tutorialsTSM}

\begin{lstlisting}[caption=Příkazy spouštějící program s výchozím správcem bezpečnosti, label=smEx]
java -Djava.security.manager HelloWorld
java -Djava.security.manager="" HelloWorld
java -Djava.security.manager=default HelloWorld
java -Djava.security.manager=java.lang.SecurityManager HelloWorld
java -Djava.security.manager=cz.test.TestovaciSM HelloWorld
\end{lstlisting}

Hodnotu konfigurační proměnné {\tt java.security.manager} při startu JVM je možné nastavit za pomoci k tomu určeného parametru {\tt -D} příkazu {\tt java}.
Je-li hodnota této konfigurační proměnné stanovena na {\tt default} nebo je-li definována bez uvedení hodnoty
(jak demonstrují první tři řádky ukázky kódu \ref{smEx}), je JVM spuštěna s výchozím správcem bezpečnosti.
\cite{javaSecurityArch}

Jinou možnou hodnotou této konfigurační proměnné je celý název třídy, jenž má být jako správce bezpečnosti použita.
Tento případ demonstrují poslední dva řádky ukázky kódu \ref{smEx}.
Je tak možné nechat o oprávněních kódu běžícího v JVM rozhodovat vlastní podtřídu výchozího správce bezpečnosti.
V rámci inicializace JVM pak bude vytvořena instance třídy určená zmíněnou konfigurační proměnnou.
Tato instance je vytvářena voláním {\tt Class.newInstance()}, tj. za pomoci jeho neparametrického konstruktoru.

Jestliže se vytvoření objektu správce bezpečnosti nezdaří, skončí celá inicializace JVM výjimkou {\tt java.lang.InternalError} \cite{sourceLauncher} a ke spuštění uživatelského programu tak vůbec nedojde.
Je tedy uplatněn bezpečnostní princip, kdy systém zůstane bezpečný i v případě poruchového stavu, třebaže na úkor funkčnosti.

%-----------------------------------------------------------------------------
\subsection{Implementace vlastního správce bezpečnosti} \label{vlastniSM}
%-----------------------------------------------------------------------------

V této podkapitole je ukázán způsob stanovení bezpečnostní politiky vytvořením vlastního správce bezpečnosti.
Jak již bylo uvedeno v kapitole \ref{securityManager}, správce bezpečnosti je objekt (pod)třídy {\tt java.lang.SecurityManager},
na který JVM, při požadavku na Java API (Application Programming Interface -- rozhraní pro programování aplikací), deleguje rozhodnutí o povolení nebo nepovolení operace nad zdrojem.

Jakmile se tedy uživatelská aplikace pokusí provést potenciálně nebezpečnou operaci (například se pokusí ukončit JVM voláním {\tt System.exit(0)}),
Java API se dotáže správce bezpečnosti na oprávněnost této operace tím, že zavolá jeho, k tomu určenou, metodu (v tomto případě {\tt checkExit(0)}). \cite[4.1.1]{oaks}

Správce bezpečnosti pak na základě parametrů tohoto volání rozhodne o tom, zda operaci zakáže a vyvolá k tomu určenou výjimku {\tt SecurityException}.
Není-li žádná výjimka vyvolána, považuje se operace za povolenou a je provedena. \cite[4.1.1]{oaks}

Bezpečnostní politiku tak můžeme definovat vytvořením vlastní podtřídy třídy {\tt SecurityManager}, kde přepíšeme metody rozhodující o povolení
operací, jejichž oprávněnost chceme stanovit.

Od Javy verze {\it Java 2 (SDK v1.2)} je možné používat univerzálnější řešení než přepisovat jednotlivé kontrolní metody.
Od této verze totiž všechny kontrolní metody (jakou je {\tt checkExit()}) delegují své rozhodnutí na metodu {\tt checkPermission()} správce bezpečnosti.
Pro stanovení bezpečnostní politiky tak stačí přepsat tuto jedinou metodu. \cite{refSecurityManager}

Příklad jednoduchého správce bezpečnosti ukazuje kód \ref{TestovaciSM}:

\begin{lstlisting}[caption=Jednoduchý správce bezpečnosti, label=TestovaciSM]
public class TestovaciSM extends SecurityManager {
	@Override
	public void checkPermission(Permission permission) {
		if(permission instanceof FilePermission){
			throw new SecurityException("Prace se soubory je zakazana!");
		}
	}
}
\end{lstlisting}

Tento jednoduchý správce bezpečnosti implementuje výše zmíněnou metodu {\tt checkPermission()}.
Ta je volána při každém pokusu o provedení potenciálně nebezpečné operace.
Je-li oprávnění, které uživatelský kód vyžaduje, třídy {\tt FilePermission} nebo její podtřídy, je vyvolána výjimka, která provedení operace zabrání.

V rámci vlastní aplikace je možné používání vlastního správce bezpečnosti vyvolat za pomoci dříve zmíněného příkazu {\tt System.setSecurityManager()}:

\begin{lstlisting}[caption=Nastavení správce bezpečnosti zevnitř JVM, label=setSM]
System.setSecurityManager(new TestovaciSM());
\end{lstlisting}

Z vně aplikace pak je možné použití tohoto správce bezpečnosti nastavit při startu JVM obdobně, jak je to popsáno v kapitole \ref{securityManager}:

\begin{lstlisting}[caption=Spuštění aplikace se správcem bezpečnosti, label=runWithSM]
java -Djava.security.manager=TestovaciSM HelloWorld
\end{lstlisting}

Vedlejším efektem existence metod volaných při každém pokusu o provedení potenciálně nebezpečné operace je také možnost vedení statistik, jaká oprávnění
aplikace nejčastěji využívá. Ty by pak teoreticky mohly být základem pro inteligentního správce bezpečnosti, přidělujícího programu oprávnění
na základě heuristické analýzy.

Z těchto statistik můžeme zjistit například to, že i v rámci vykonávání prázdného programu v Javě (třídy, jejíž metoda {\tt main()} neobsahuje žádný příkaz) je prováděno celkem 29 potenciálně nebezpečných operací.
V 18 případech je příčinou dotazu čtení obsahu konfiguračních proměnných ({\it Property}), v 8 případech jde o manipulaci s vlákny ({\it Thread}) a ve zbývajících 3 případech jde o čtení souboru spouštěné třídy ({\tt Program.class}). Ve všech případech jde tedy o operace související se samotnou inicializací JVM.

Pro stanovení bezpečnostní politiky se však tento způsob (vytvoření vlastního správce bezpečnosti) v současnosti již nepoužívá, ačkoli stále možný je.
Důvodem je, že vyžaduje od správce serveru, na němž aplikace běží, znalosti programování.
Neumožňuje navíc jednoduchým způsobem přidělovat oprávnění v závislosti na třídě, která se potenciálně nebezpečnou operaci snaží provést.

%=============================================================================
\section{Zavaděče tříd} \label{classloader}
%=============================================================================

Než se dostaneme k v současnosti využívanému způsobu stanovování bezpečnostní politiky, pozastavíme se nad tématem zavádění tříd.
Ačkoli se na první pohled může zdát, že toto téma s bezpečností příliš nesouvisí, opak je pravdou.
Jen a pouze zavaděč tříd ({\it classloader}), který třídu do paměti zavádí, totiž může určit původ třídy, od kterého se oprávnění kódu této třídy zpravidla odvozuje.

Zavaděč je objekt odpovědný za načítání tříd a rozhraní v Javě. Na základně binárního názvu třídy ({\it binary name of class}) \cite{binaryNameOfClass}, tedy označení třídy používaného v bajtkódu (např. {\tt java.lang.String} nebo {\tt java.security.KeyStore\$Builder\$FileBuilder\$1}), se tuto třídu pokusí vyhledat a načíst do paměti. \cite{refClassLoader}

Třída každého zavaděče tříd musí být podtřídou třídy {\tt java.lang.ClassLoader} a musí implementovat metodu {\tt findClass()}. Ta je jádrem celého zavaděče -- provádí samotné vyhledání třídy podle názvu. Jejím výstupem je objekt třídy {\tt java.lang.Class}, představující samotnou třídu. \cite{refClassLoader}

\begin{lstlisting}[caption=Získávání názvu třídy neznámého objektu, label=getClassName]
Class classOfUnknown = unknown.getClass();
String nameOfClass = classOfUnknown.getName(); // "java.lang.String"
\end{lstlisting}

Při programování běžných aplikací můžeme objekty tříd využít například při snaze získat název třídy neznámého objektu jako řetězec za běhu aplikace,
jak ukazuje ukázka kódu \ref{getClassName}.

První řádek ukazuje získání objektu třídy (objektu třídy {\tt Class}) neznámého objektu.
To je možné díky tomu, že každý objekt v Javě si uchovává referenci na svoji třídu.

Druhý řádek pak ze získaného objektu třídy získává název této třídy.
Objekt třídy dále obsahuje například seznam atributů ({\tt java.lang.reflect.Field}), metod ({\tt java.lang.refl ect.Method})
nebo anotací ({\tt java.lang.annotation.Annotation}). \cite{sourceClass}

%-----------------------------------------------------------------------------
\subsection{Zdroje kódu a ochranné domény} \label{codeSourceAprotectionDomains}
%-----------------------------------------------------------------------------

Zdroj kódu ({\tt java.security.CodeSource}) je souhrnem informací určujících původ třídy:~\cite{sourceCodeSource}

\begin{itemize}
  \item {\tt location}: URL adresa, ze které byla třída načtena.
  \item {\tt signers[]} / {\tt certs[]}: Pole podepsaných autorů kódu nebo pole jejich certifikátů. Tyto dvě informace jsou vzájemně odvoditelné. Pro vytvoření objektu zdroje kódu postačuje jedna z nich a druhá z ní může být v případě potřeby kdykoli odvozena.
\end{itemize}

Ochranná doména ({\tt java.security.ProtectionDomain}) je objektem spojujícím objekt třídy ({\tt Class}) se zdrojem kódu ({\tt CodeSource}) a oprávněními ({\tt Permission}). Konkrétně se skládá z následujících informací: \cite{sourceProtectionDomain}

\begin{itemize}
  \item {\tt codesource}: Zdroj kódu třídy reprezentovaný výše rozebranou třídou.
  \item {\tt classloader}: Zavaděč tříd, kterým byla ochranná doména přidělena.
  \item {\tt principals}: Role uživatele přihlášeného k programu. (viz kapitola \ref{staticPerm})
  \item {\tt permissions}: Statická oprávnění kódu třídy. (viz kapitola \ref{staticPerm})
\end{itemize}

Každá třída spadá vždy do jedné ochranné domény, která může být společná více třídám. Za nastavení ochranné domény i zdroje kódu odpovídá zavaděč třídy.
Jen ten totiž může původ třídy znát, protože právě on získání jejího kódu a ověření jejího podpisu zajišťuje.

%-----------------------------------------------------------------------------
\subsection{Systémový zavaděč tříd} \label{interniZavadec}
%-----------------------------------------------------------------------------

Systémový zavaděč tříd je zavaděč používaný pro načítání tříd samotného Java API a zavaděčů uživatelských tříd.
Je napsán převážně v nativním kódu a je součástí JVM. K načítání tříd tedy využívá nativní metody pro přístup k souborovému systému operačního systému.
Třídy načítá ze souborů, jejíž adresu odvozuje z názvu třídy, balíčku a proměnné prostředí {\tt CLASSPATH}. \cite[3.2.1]{oaks}

Je-li tedy JVM spuštěna příkazem uvedeným v ukázce kódu \ref{javaClasspath}, bude spuštěna třídní metoda {\tt main()} třídy {\tt Test}
ze souboru {\tt /srv/classes/my/program/Test.class}.

\begin{lstlisting}[caption=Spuštění JVM s hodnotou proměnné {\tt CLASSPATH} rovnou {\tt /srv/classes}, label=javaClasspath]
java -classpath /srv/classes my.program.Test
\end{lstlisting}

Systémový zavaděč je používán k načítání jen nejzákladnějších tříd, zejména tříd Java API a dalších tříd potřebných k provozu jiných zavaděčů tříd.
Ostatní třídy z {\tt CLASSPATH} jsou pak načítány jinými zavaděči, typicky zavaděčem tříd z URL, jež bude popsán dále, v kapitole \ref{URLClassLoader}.

O třídách načtených systémovým zavaděčem se často mluví jako o třídách bez zavaděče, protože jejich objekt {\tt Class} má referenci na zavaděč nastavenu na {\tt null}. \cite[3.2.1]{oaks} Zároveň je rovna {\tt null} také ochranná doména takto načtených tříd. Třídy načtené systémovým zavaděčem tak nemají svá oprávnění omezena. \cite[5.4]{oaks}

%-----------------------------------------------------------------------------
\subsection{Zavaděč tříd z URL} \label{URLClassLoader}
%-----------------------------------------------------------------------------

Zavaděč tříd z URL ({\tt URLClassLoader}) hledá třídy na URL adresách předaných jeho konstruktoru. Je jedním z nejpoužívanějších zavaděčů tříd v Javě,
protože je implicitním zavaděčem používaným k načítání tříd z adres určených proměnnou {\tt CLASSPATH}.

Dokáže třídy načítat nejen z adresářů, ale i z JAR archivů, je-li jako adresa uvedena adresa JAR archivu. \cite[3.2.5]{oaks}

Zavaděč tříd z URL je, tak jako většina zavaděčů, jedním z bezpečných zavaděčů ({\tt SecureClassLoader}).
To znamená, že nastavuje ochrannou doménu třídám, které načítá.

Třídy pocházející ze stejného zdroje (s odpovídajícím {\tt CodeSource}) patří do stejné ochranné domény a mají tak stejná statická oprávnění.
(viz kapitola \ref{staticPerm})
Navrácení vždy stejného objektu ochranné domény přitom zavaděč zajišťuje pomocí asociativního pole {\tt SecureClassLoader.pdcache},
jehož klíčem je objekt zdroje kódu a hodnotou objekt ochranné domény.
\cite{sourceSecureClassLoader}

%=============================================================================
\section{Systém řízení přístupu a soubory bezpečnostní politiky}
%=============================================================================

Systém řízení přístupu ({\it Access controller}) je mechanismus využívající ochranné domény tříd na zásobníku volání k rozhodnutí, zda operaci požadovanou programem povolit či nikoliv.

Na oprávněnost volajícího kódu provést vybranou akci se jej může dotazovat uživatelský kód a veškeré rozhodování na něj zároveň deleguje standardní správce bezpečnosti v Javě verze 2 a novějších. \cite[5]{oaks}

Systém řízení přístupu tedy, stejně jako správce bezpečnosti, umožňuje omezit, zdali může být operace nad zdrojem provedena nebo ne. Zdroji zde však již nejsou jen zdroje samotné JVM. Uživatelské programy mohou systém řízení přístupu využívat také k omezení přístupu k vlastním zdrojům, které dále poskytují. \cite[5]{oaks}

Máme-li tedy například knihovnu zprostředkovávající přístup k databázi v souboru po záznamech, při použití oprávnění jen na úrovni Java API by bylo možné programu přidělovat oprávnění jen k celému souboru najednou. Jednotlivé záznamy databáze v souboru je však možné považovat za samostatné zdroje knihovny. Knihovna pak může využít systém řízení přístupu k jejich ochraně.

Systém řízení přístupu je schopný pravidla bezpečnostní politiky načítat z textového konfiguračního souboru -- tzv. souboru bezpečnostní politiky. Vzniká tak mnohem snazší způsob stanovení bezpečnostní politiky -- namísto tvorby vlastní třídy správce bezpečnosti stačí pro stanovení bezpečnostní politiky poupravit textový soubor bezpečnostní politiky. \cite[5]{oaks}

Systém řízení přístupu rozhoduje o povolení potenciálně nežádoucí operace na základě oprávnění třídy, jejíž metoda tuto operaci vyvolala i oprávnění tříd,
jenž vyvolaly provádění této metody.
Množina oprávnění, které prováděný kód v danou chvíli má, tak odpovídá průniku oprávnění všech těchto tříd -- tříd na zásobníku volání.

Jestliže tedy metoda {\tt a()} třídy {\tt A} volá metodu {\tt b()} třídy {\tt B} a metoda {\tt b()} se pokusí provést potenciálně nebezpečnou operaci,
aby systém řízení přístupu operaci povolil, musí obě třídy, {\tt A} i {\tt B} mít přiděleno potřebné oprávnění.

Na legálnost operace se systému řízení přístupu může dotazovat samotná volaná metoda (voláním metody {\tt AccessController.checkPermission()}), nebo správce bezpečnosti na základě dotazu na legálnost operace od Java API. V obou případech bude operace povolena jen pokud budou potřebným oprávněním disponovat všechny třídy na zásobníku volání.

%-----------------------------------------------------------------------------
\subsection{Implementace a použití systému řízení přístupu}\label{implementaceAC}
%-----------------------------------------------------------------------------

Systém řízení přístupu je implementován třídou {\tt AccessController}. Voláním jeho statických metod na něj standardní správce bezpečnosti deleguje rozhodnutí o povolení provedení potenciálně nežádoucí operace uživatelským programem. Samotnou kontrolu provádí jeho metoda {\tt checkPermission(Permission)}, která v případě neoprávněnosti požadavku na provedení operace vyvolá výjimku {\tt AccessControlException}. Jejím vstupem je objekt třídy {\tt Permission}, který reprezentuje oprávnění, jehož vlastnictví je testováno. \cite[5.5]{oaks}\cite[6]{oaks}

Ukázka kódu \ref{pouzitiAccessControlleru} ukazuje způsob, jakým se může kód dotázat systému řízení přístupu, zdali má zadané oprávnění. \cite[5.5]{oaks}

\begin{lstlisting}[caption=Příklad položení dotazu systému řízení přístupu, label=pouzitiAccessControlleru]
try {
    // ma tento program opravneni pripojit se na lokalni port 80?
    AccessController.checkPermission(
        new SocketPermission("localhost:80", "connect")
    );
    System.out.println("Pripojeni bylo povoleno");
} catch (AccessControlException e) {
    System.out.println("Pripojeni bylo zamitnuto");
}
\end{lstlisting}

Dotaz je položen voláním metody {\tt AccessController.checkPermission()}, přičemž je jako parametr připojen objekt oprávnění.
Má-li kód toto oprávnění, provádění pokračuje a je tak na standardní výstup vypsáno, že operace byla povolena.
V opačném případě je vyvolána výjimka {\tt AccessControlException}, která je v této ukázce odchycena a na standardní výstup je v takovém případě vypsáno, že operace byla zamítnuta.

%-----------------------------------------------------------------------------
\subsection{Třídy oprávnění}
%-----------------------------------------------------------------------------

Třídy oprávnění představují typ zdroje, ke kterému lze přidělovat oprávnění. Musí být podtřídami třídy {\tt Permission}, ale pro jednodušší implementaci jsou často odvozovány od její podtřídy {\tt BasicPermission}.

Aby bylo možné třídu oprávnění použít, musí být definován její konstruktor. Jeho parametry musejí odpovídat parametrům v souboru bezpečnostní politiky. Musí být také veřejně přístupný -- opatřený specifikátorem přístupu {\tt public}.

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Příklad třídy oprávnění} \label{zaznamPerm}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Ukázka kódu \ref{prikladTridyOpravneni} ukazuje nejjednodušší způsob vytvoření vlastní třídy oprávnění. Jako příklad je zde použita třída oprávnění z příkladu s knihovnou pro přístup k záznamům v databázovém souboru. (Později bude využita v příkladu v kapitole \ref{databazeVsouboru}).

\begin{lstlisting}[caption=Demonstrační třída oprávnění, label=prikladTridyOpravneni]
public class ZaznamPermission extends java.security.BasicPermission {
    public ZaznamPermission(String name, String actions) {
        super(name, actions);
    }
}
\end{lstlisting}

%-----------------------------------------------------------------------------
\subsection{Privilegované bloky kódu}\label{privilegovaneBloky}
%-----------------------------------------------------------------------------

Vraťme se nyní k našemu příkladu s knihovnou pro přístup k databázi v souboru, kde chceme různým programům přidělovat oprávnění k jednotlivým databázovým záznamům jako k samostatným zdrojům systému, ale zároveň jim nechceme povolit přístup ke zbytku databázového souboru.

Ze způsobu fungování systému řízení přístupu, jak jsme si jej zatím popsali, totiž vyplývá, že aby mohla knihovna zprostředkovávající přístup k databázi přistupovat k databázovému souboru, musí mít oprávnění pracovat s tímto souborem jak samotná databázová knihovna, tak i každá třída podílející se na jejím volání.

Tento stav je samozřejmě nepřípustný, protože oprávnění na úrovni uživatelského kódu by tímto ztratila význam. Pokud by uživatelský kód neměl oprávnění přímo přistupovat k databázovému souboru, nemohla by mu přístup k němu zprostředkovat ani tato knihovna. Pokud by naopak uživatelský kód oprávnění k databázovému souboru dostal, mohl by naopak obejít kód knihovny zajišťující kontrolu oprávnění k jednotlivým záznamům a přistupovat tak k datům v celé databázi libovolně bez ohledu na oprávnění k jednotlivým záznamům.

Právě tento problém řeší privilegované bloky kódu. Kód v privilegovaném bloku je spuštěn se samostatným zásobníkem volání. Při ověřování oprávnění při přístupu k jakémukoli zdroji tak ověřování skončí u třídy s tímto blokem. \cite{refAccessController}

Část kódu knihovny, jež vložíme do privilegovaného bloku, bude tedy spuštěna s oprávněními této knihovny bez ohledu na oprávnění kódu, jež metodu knihovny zavolal.

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Příklad použití privilegovaného bloku}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Ukázka kódu \ref{prikladBloku} ukazuje jednoduchý příklad použití privilegovaného bloku: \cite{refAccessController}

\begin{lstlisting}[caption=Příklad použití privilegovaného bloku, label=prikladBloku]
class DatabazeVSouboru {
 public void provedOperaciNadDatabazi(){
  // Zde bude kod omezen opravnenimi volajici tridy
  String s = AccessController.doPrivileged(new PrivilegedAction<String>(){
   public String run(){
    // Zde bude kod spusten nezavisle na opravnenich volajici tridy
    return "privileged";
   }
  }
 }
}
\end{lstlisting}

Metoda {\tt provedOperaciNadDatabazi()} je spuštěna omezená oprávněními kódu, který ji zavolal.
Volá metodu {\tt doPrivileged()} systému řízení přístupu, čímž privilegovaně spouští kód metody {\tt run()} objektu, který metodě {\tt doPrivileged()} předal.
Kód metody {\tt run()} je tedy spuštěn bez ohledu na oprávnění tříd, jejichž metody volaly metodu {\tt provedOperaciNadDatabazi()}.

Datový typ návratové hodnoty metody {\tt run()} je určen parametrem datového typu {\tt PrivilegedAction}.
Tato návratová hodnota je pak vrácena také metodou {\tt doPrivileged()}.
Tímto datovým typem však mohou být jen třídy objektů, ne primitivní datové typy.
Má-li tedy být výstupem privilegovaně spuštěného kódu primitivní datový typ, je nutné použít obalové třídy, jakou je např. {\tt java.lang.Integer}.

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Příklad s knihovnou pro přístup k databázi}\label{databazeVsouboru}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Ukázka kódu \ref{pouzitiBloku} ukazuje možnou implementaci knihovny pro přístup k databázi navržené v kapitole \ref{privilegovaneBloky}.

\begin{lstlisting}[caption=Demonstrační knihovna pro přístup k databázi, label=pouzitiBloku]
class DatabazeVSouboru {
  public Zaznam nactiZaznam(String klic){
    // volajici kod musi mit opravneni k nacteni zaznamu
    AccessController.checkPermission(new ZaznamPermission(klic,"nacteni"));
    
    return AccessController.doPrivileged(new PrivilegedAction<Zaznam>() {
      public Zaznam run() {
        // provedeni operace nad samotnymi daty (s opravnenimi knihovny)
      }
    });
  }
}
\end{lstlisting}

Kód jež nemá oprávnění pro přístup k souboru volá metodu {\tt nactiZaznam()}.
Tato metoda nejprve voláním {\tt checkPermission()} zkontroluje, zdali má tento kód oprávnění pro přístup k danému záznamu.
Pro tento 


Každá metoda knihovny zpřístupňující záznam v databázi nejprve ověří oprávněnost požadavku na přístup k danému záznamu. Tato kontrola se provede stejně jako v ukázce kódu \ref{pouzitiAccessControlleru}, voláním metody {\tt checkPermission()}.

Zde je důležité poznamenat že tato kontrola se musí provést mimo privilegovaný blok, čímž bude vlastnictví kontrolovaného oprávnění vyžadováno nejen od kódu samotné knihovny, ale také od kódu, jež tuto operaci nad záznamem vyvolal. Pokud některá z tříd na zásobníku volání nebude mít požadované oprávnění, provádění operace nad databází bude přerušeno výjimkou systému řízení přístupu ({\tt java.security.AccessControlException}).

V opačném případě se pokračuje provedením samotné operace nad databází v rámci privilegovaného bloku. Tím bude tato operace provedena s oprávněními třídy knihovny, nezávisle na oprávněních kódu, jež metodu knihovny volal. Aby se tak samotná operace nad databázovým souborem provedla, bude postačovat přidělení oprávnění třídě knihovny.

%-----------------------------------------------------------------------------
\subsection{Soubory bezpečnostní politiky} \label{souboryBP}
%-----------------------------------------------------------------------------

Tato kapitola popisuje implementaci bezpečnostních politik za pomoci souborů bezpečnostní politiky.

Soubor bezpečnostní politiky se skládá z deklarací původů tříd a jim přidělovaných oprávnění.
Původ třídy je zde stanoven na základě podpisu JAR archivu, z kterého byla třída získána (direktiva {\tt signedBy}), URL kořene systému balíčků tříd (packages), ze kterého byla třída získána (direktiva {\tt codeBase}) nebo obou těchto kritérií najednou. \cite[5.3.1]{oaks}

Syntaxe souboru bezpečnostní politiky, používané standardní implementací bezpečnostní politiky {\tt PolicyFile}, je ukázána v ukázce kódu \ref{syntaxeSouboruBP}. \cite[5.3.1]{oaks}\cite{refPolicyFiles}

\begin{lstlisting}[caption=Syntaxe souboru bezpečnostní politiky, label=syntaxeSouboruBP]
grant signedBy "autor", codeBase "/koren", principal Trida "jmeno@realm" {
    permission TridaOpravneni "parametry","konstruktoru";
    ...
};
\end{lstlisting}

Jak je vidět, oprávnění jsou přidělována kombinacím podepsaného autora ({\tt signedBy}), kořene systému balíčků ({\tt codeBase}) a identifikátoru uživatele nebo role ({\tt principal}).
Samotná oprávnění pak jsou definována názvem třídy oprávnění a parametry jeho konstruktoru oddělenými čárkami.

Jestliže třída v době načítání souboru bezpečnostní politiky není dostupná, je oprávnění uloženo do dočasného objektu speciální třídy {\tt java.security.UnresolvedPermission}.
Stane-li se tato třída později dostupnou, je dočasný objekt nahrazen instancí této třídy při kontrole tohoto oprávnění systémem řízení přístupu. \cite{refUnresolvedPermission}

\begin{figure}[ht]
  \centering
  \includegraphics[width=12cm]{fig/policy-schema}
  \caption{Třídy podílející se na politice postavené na souborech politiky.}
  \label{tridyPolicyFile}
\end{figure}

Třídy podílející se na bezpečnostní politice postavené na souborech bezpečnostní politiky ukazuje diagram tříd na obrázku \ref{tridyPolicyFile}.
Tuto politiku realizuje třída {\tt PolicyFile}, podtřída třídy {\tt Policy}, která představuje obecnou bezpečnostní politiku.

Objekt politiky {\tt PolicyFile} provádí rozhodnutí o oprávněnosti operací na základě aktuálního objektu {\tt PolicyInfo}.
Tento objekt obsahuje množinu položek bezpečnostní politiky, {\tt PolicyEntry}.

Protože tato množina je v průběhu načítání souborů bezpečnostní politiky tvořena postupně, je umístěna v tomto samostatném objektu.
Díky tomu je bezpečnostní politika vyměňována atomicky -- jeden objekt {\tt PolicyInfo} je v rámci atomické reference nahrazen novým.
V průběhu výměny bezpečnostní politiky tak nemůže dojít k okamžiku, kdy by byla uplatňována jen z části načtená politika.

K inicializaci a tedy i k načítání politiky ze souborů dochází při vytváření objektu {\tt PolicyFile} a při volání jeho metody {\tt refresh()}.
V obou případech jsou soubory politiky určeny konfiguračními proměnnými ({\it property}) popsanými v kapitole \ref{nastaveniPolitiky}.

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Příklad souboru bezpečnostní politiky}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Tento příklad ukazuje jednoduchou bezpečnostní politiku, opět v kontextu příkladu knihovny pro přístup k databázi z kapitoly \ref{databazeVsouboru}.

\begin{lstlisting}[caption=Příklad souboru bezpečnostní politiky, label=prikladSouboruBP]
grant codeBase "file:/srv/program/" {
  permission ZaznamPermission "Lucka", "nacteni";
};
grant codeBase "file:/srv/knihovna/" {
  permission ZaznamPermission "*", "nacteni";
  permission java.io.FilePermission "/srv/knihovna/data/-","read,write";
};
\end{lstlisting}

Program zde má přiděleno oprávnění k načtení záznamu \uv{Lucka}. Třída tohoto oprávnění byla definována v kapitole \ref{zaznamPerm}.
Nemá ale přiděleno oprávnění k přístupu k samotným databázovým souborům.
K těm má oprávnění přistupovat jen knihovna zpřístupňující tuto databázi, popsaná v kapitole \ref{databazeVsouboru}.
Kvůli způsobu implementace kontroly oprávnění systémem řízení přístupu (popsaným v kapitole \ref{implementaceAC}) je nezbytné přidělit knihovně oprávnění ke všem záznamům v databázi, jinak by žádná kontrola oprávněnosti požadavku nemohla skončit pozitivně.

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Zástupné znaky}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

URL kořene systému balíčků může být v souboru bezpečnostní politiky ukončeno zástupnými znaky pomlčka ({\tt -}) a hvězdička ({\tt *}).

Zatímco {\tt /*} odpovídá všem souborům v daném adresáři, {\tt /-} odpovídá všem souborům v daném adresáři i jeho podadresářích, rekurzivně.
V obou případech jsou zahrnuty jak soubory tříd ({\tt .class}), tak i celé archivy tříd ({\tt .jar}/{\tt .war}/{\tt .ear}).
Archivy vnořené v těchto archivech však již prohledávány nejsou.
\cite{jdkdocPolicyFiles}

%-----------------------------------------------------------------------------
\subsection{Nastavení třídy a souboru bezpečnostní politiky} \label{nastaveniPolitiky}
%-----------------------------------------------------------------------------

Tato kapitola popisuje nastavení implicitní třídy a souborů bezpečnostní politiky. Změna těchto nastavení dovoluje správci počítače
stanovit bezpečnostní politiku aplikovanou implicitně na všechny programy v Javě běžící na daném počítači.

Používaná třída a soubory bezpečnostní politiky jsou určeny globálně, pro celé běhové prostředí Javy (JRE -- Java Runtime Environment),
v konfiguračním souboru {\tt java.security} umístěném v podadresáři {\tt lib/security} adresáře JRE. \cite{refPolicyFiles}

Třída bezpečnostní politiky je určena svým celým jménem (např. {\tt sun.security.provider{\linebreak}.PolicyFile}) v konfigurační proměnné {\tt policy.provider}. \cite{refPolicyFiles}

Soubory bezpečnostní politiky jsou určeny svou absolutní adresou, uvedenou včetně protokolu (pro lokální soubory {\tt file:}),
v konfiguračních proměnných {\tt policy.url.n}, kde {\tt n} je pořadové číslo souboru. \cite{refPolicyFiles}

Načítání souborů bezpečnostní politiky začíná od {\tt policy.url.1} a postupně se {\tt n} inkrementuje a načítají se jednotlivé soubory bezpečnostní politiky,
dokud {\tt policy.url.n} existuje. \cite{refPolicyFiles}

\begin{lstlisting}[caption=Význačnější proměnné konfiguračního souboru {\tt java.security}, label=javasecurityexample]
policy.provider=sun.security.provider.PolicyFile
policy.url.1=file:${java.home}/lib/security/java.policy
policy.url.2=file:${user.home}/.java.policy
policy.url.3=file:/my-policies/my.policy
\end{lstlisting}

Příklady nastavení konfiguračních proměnných v tomto souboru jsou uvedeny v ukázce kódu \ref{javasecurityexample}, která je rozšířením příkladu z knihy pana Oakse. \cite[5.3.1]{oaks}

Nastavenou třídou bezpečnostní politiky je zde třída {\tt PolicyFile} a jako soubory bezpečnostní politiky jsou použity
soubory {\tt \$\{java.home\}/lib/security/java.policy}, {\tt \$\{user{\linebreak}.home\}/.java.policy} a {\tt /my-policies/my.policy} v uvedeném pořadí.

Implicitně jsou používány právě první dvě uvedená umístění -- {\tt \$\{java.home\}/lib/secu{\linebreak}rity/java.policy} pro celý systém a {\tt \$\{user.home\}/.java.policy} jako jeho rozšíření pro jednotlivé uživatele. Poslední umístění je přidáno pro demonstraci, jak je možné přidat další umístění. \cite{refSecurity}

Bezpečnostní politiku je dále možné rozšířit při startu JVM o další soubor bezpečnostní politiky. Stačí nastavit konfigurační proměnnou {\tt java.security.policy} při startu JVM: \cite[5.3.1]{oaks}

\begin{lstlisting}[caption=Spuštění JVM s vlastním souborem bezpečnostní politiky, label=nastaveniBP]
java -Djava.security.policy=dalsi_soubor_politiky.policy ProgramABC
\end{lstlisting}

V tomto případě bude uvedený soubor bezpečnostní politiky použit zároveň s výše uvedeným standardním souborem bezpečnostní politiky. Chceme-li standardní soubory bezpečnostní politiky určené souborem {\tt java.security} zcela nahradit, stačí namísto jednoho rovnítka v definici konfigurační proměnné použít rovnítka dvě: \cite[5.3.1]{oaks}

\begin{lstlisting}[caption=Spuštění JVM jen s vlastním souborem bezpečnostní politiky, label=nastaveniBP2]
java -Djava.security.policy==jediny_soubor_politiky.policy ProgramABC
\end{lstlisting}

Obsah této proměnné je možné změnit i za běhu programu, má-li daná část programu oprávnění k zápisu do této proměnné.

\begin{lstlisting}[caption=Nastavení souboru bezpečnostní politiky zevnitř JVM, label=nastaveniBP3]
System.setProperty("java.security.policy", "jiny_soubor_politky.policy");
\end{lstlisting}

Protože, jak již bylo zmíněno v kapitole \ref{souboryBP}, nové načtení bezpečnostní politiky ze souborů bezpečnostní politiky je možné provést
skrze metodu {\tt refresh()} objektu bezpečnostní politiky, je možné provedenou změnu bezpečnostní politiky nechat projevit jejím zavoláním:

\begin{lstlisting}[caption=Znovunačtení souboru bezpečnostní politiky, label=refreshBP]
Policy.getPolicy().refresh();
\end{lstlisting}

Problémem je, že tato metoda je označena jako nedoporučovaná ({\it deprecated}), protože je implementačně závislá -- zatímco u třídy bezpečnostní politiky {\tt PolicyFile} správně způsobí projevení změn v souboru bezpečnostní politiky, u jiných implementací bezpečnostní politiky může být implementována jako prázdná operace. \cite{refPolicy}

Tato práce se proto bude zabývat jen bezpečnostními politikami poskytovanými standardní implementací třídy {\tt Policy}, {\tt sun.security.provider.PolicyFile}, a na ní postavených nebo na ni delegujících implementacích.

%-----------------------------------------------------------------------------
\subsection{Statická a dynamická oprávnění ochranných domén} \label{staticPerm}
%-----------------------------------------------------------------------------

Oprávnění ochranných domén ({\tt ProtectionDomain}) popsaných v kapitole \ref{codeSourceAprotectionDomains} jsou ukládány přímo v objektech těchto ochranných domén,
konkrétně v jejich atributu {\tt permissions}.~\cite{sourceProtectionDomain}

Protože jsou tato oprávnění do ochranné domény ukládány při jejím vytváření, tedy při zavádění třídy a následně nemohou být změněna, označujeme je jako statická.

Ochranné domény však souběžně mohou používat ještě oprávnění dynamická. Není-li ochranná doména označena jako používající výhradně statická oprávnění,
dotazuje se ochranná doména na oprávnění objektu bezpečnostní politiky při každém volání její metody {\tt implies()}.
Takto získaná oprávnění pak označujeme jako dynamická. \cite{sourceProtectionDomain}
Jsou-li dynamická oprávnění použita, efektivní oprávnění uplatňovaná metodou {\tt implies()} budou sjednocením dynamických a statických oprávnění třídy.
\cite{sourceProtectionDomain}

V současnosti jsou obvykle preferována oprávnění dynamická, jež poskytují vyšší variabilitu tím, že je možné bezpečnostní politiku vyměňovat za běhu
programu -- změny v ní se projeví jakmile začne být uplatňována metodou {\tt implies()} objektu bezpečnostní politiky, tedy zpravidla po volání metody
{\tt refresh()} používaného objektu bezpečnostní politiky.

Dynamická oprávnění jsou používána na všechny třídy zaváděné zavaděčem tříd z URL (viz \ref{URLClassLoader}) a jsou tedy využívána ve většině programů v Javě.
\cite{sourceURLClassLoader}

Umožňují navíc přidělovat oprávnění nejen na základě zdroje kódu, ale také na základě rolí uživatele spouštějícího daný kód. Tato dvě kritéria se však
obvykle používají pouze samostatně -- buď systém řízení přístupu ověřuje oprávnění kódu provést požadovanou operaci, nebo uživatelský kód ověřuje oprávnění
uživatele, který jej spouští, k provedení požadované operace. V obou případech se však stále jedná o dynamická oprávnění.

Statická oprávnění byla v Javě donedávna implementována jen v zájmu zachování kompatibility s verzemi Javy staršími než Java 2 SE 1.4. \cite{sourceProtectionDomain}
V současnosti se však statická oprávnění opět začaly používat a to za účelem optimalizace.
Získáváním oprávnění třídy z objektu bezpečnostní politiky pouze při zavádění třídy a ne při každém požadavku o ověření oprávněnosti k provedení operace je totiž možné proces ověřování oprávněnosti urychlit.

%=============================================================================
\section{Celkový pohled na bezpečnost v Javě} \label{celkovyPohled}
%=============================================================================

\begin{figure}[ht]
  \centering
  \includegraphics[width=14cm]{fig/domain-schema}
  \caption{Diagram datových toků tříd (hnědé šipky) a oprávnění tříd (černé šipky) v Javě}
  \label{diagramDatovychToku}
\end{figure}

Diagram datových toků na obrázku \ref{diagramDatovychToku} ukazuje putování informace o oprávněních třídy ze souboru bezpečnostní politiky až do systému řízení přístupu a správce bezpečnosti. Souvislé černé šipky představují přenos informace o oprávněních, zatímco hnědé přenos informace o třídách. Přerušované šipky představují reference. Směr šipky pak vede z třídy objektu s referenční proměnnou do třídy referencovaného objektu.

Ochranné domény a tím i statická oprávnění třídy jsou třídám přidělovány při jejich zavádění. Objekty ochranných domén ({\tt ProtectionDomain}) vytváří zavaděč tříd a to na základě jejich zdroje kódu ({\tt CodeSource}). Na statická oprávnění, která má zdroji kódu (a tedy i vytvořené ochranné doméně) zavaděč přidělit, se dotazuje aktuálně používaného objektu bezpečnostní politiky ({\tt Policy}).

Výstupem zavaděče tříd pak je objekt třídy ({\tt java.lang.Class}), jež nese referenci na svoji ochrannou doménu, která je společná všem objektům se stejným zdrojem kódu.

Systém řízení přístupu ({\tt java.security.AccessController}) pak rozhoduje na základě oprávnění v ochranné doméně a není-li ochranná doména označena jako používající výhradě statická oprávnění, také na základě odpovědi objektu bezpečnostní politiky ({\tt Policy}).

Na systém řízení přístupu pak rozhodování deleguje také standardní správce bezpečnosti ({\tt java.lang.SecurityManager}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Distribuované prostředí Red Hat JBoss} \label{jboss}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\section{Úvod do WildFly (JBoss AS)} \label{uvodWildFly}
%=============================================================================

WildFly, dříve známý jako JBoss Application Server, je aplikační server standardu Java EE (Enterprise Edition).
Poskytuje běhové prostředí (nejen) Java EE aplikacím, které jsou na tomto aplikačním serveru nainstalovány.
\cite{wildflyRename}

Jednotlivé instalace WildFly nazýváme hostiteli ({\it host}). Hostitel typicky odpovídá jednomu fyzickému serveru.
V rámci každého hostitele může běžet více serverů ({\it server}).
Hostitelé mohou být spojováni do domén ({\it domain}), přičemž jeden z nich v takovém případě zastává roli tzv. doménového řadiče ({\it domain controller}).
Ostatní hostitelé domény se k němu pak registrují a je na ně aplikována doménová konfigurace.
\cite{jbossDomainSetup}

Doménová konfigurace je uložena v konfigurační souboru domény, {\tt domain.xml}, uložené právě na doménovém řadiči.
Tento soubor obsahuje konfiguraci skupin serverů a profilů serverů.
Konfigurace profilů pak zahrnuje také konfiguraci subsystémů používaných na serverech domény používajících daný profil.
\cite{jbossDomainSetup}

Každý hostitel má zároveň vlastní konfigurační soubor {\tt host.xml}.
Tento soubor určuje název hostitele, zda-li je tento hostitel doménovým řadičem a, pokud není, také adresu doménového řadiče.
Zde jsou definovány servery, které na daném hostiteli poběží, porty na kterých budou poskytovat své služby a skupiny do kterých budou patřit.
\cite{jbossDomainSetup}

Distribuovanosti prostředí je docíleno nasazováním aplikací ({\it deployment}) na celé skupiny serverů najednou.
Požadavky směřované na aplikace pak jsou rozprostírány mezi všechny servery domény osazené danou aplikací pomocí tzv. vyvažovačů zátěže ({\it load balancer}).
\cite{jbossLoadBalancing}

Vyvažovač zátěže umožňuje skrýt celou doménu serverů za jedinou IP adresu.
Na této adrese pak naslouchá požadavkům a předává je jednotlivým serverům této domény -- zpravidla tomu, který je v daný okamžik nejméně vytížený.
\cite{jbossLoadBalancing}

%=============================================================================
\section{Běh WildFly se správcem bezpečnosti}
%=============================================================================

Tato podkapitola se zabývá problémem používání správce bezpečnosti a bezpečnostních politik v prostředí JBoss/WildFly.

Na první pohled se může zdát, že nakonfigurovat použití správce bezpečnosti na aplikační server WildFly je možné stejně jako na jakoukoli jinou aplikaci v Javě -- nastavením patřičných konfiguračních vlastností (popsaných v kapitolách \ref{securityManager} a \ref{nastaveniPolitiky}) při startu JVM za pomoci příslušných parametrů příkazu {\tt java}.

Ve spouštěcím skriptu WildFly ({\tt standalone.sh} / {\tt domain.sh} / {\tt standalone.bat} / {\tt domain.bat}) je pro potřeby přidávání vlastních parametrů příkazu {\tt java} používána proměnná {\tt JAVA\_OPTS}.
Připojením potřebných parametrů na konec hodnoty této proměnné bychom tedy měli dosáhnout použití správce bezpečnosti a stanovené bezpečnostní politiky ve všech JVM aplikačního serveru. Každý řádek ukázky kódu \ref{wildflySeSM} tedy přidá na konec proměnné {\tt \$JAVA\_OPTS} jeden parametru příkazu {\tt java}. \cite{jbossSecurityManager}

\begin{lstlisting}[caption=Doplnění spouštěcího skriptu o použití správce bezpečnosti, label=wildflySeSM]
JAVA_OPTS="$JAVA_OPTS -Djava.security.manager"
JAVA_OPTS="$JAVA_OPTS -Djava.security.policy==wildfly.policy"
\end{lstlisting}

Uvedený soubor bezpečnostní politiky ({\tt wildfly.policy}) prozatím ponecháme prázdný.
Zkusíme-li nyní aplikační server spustit, spuštění skončí neúspěchem kvůli chybějícím oprávněním, nezbytných k běhu aplikačního serveru. Tento výsledek je ale pro nás pozitivní, neboť prokazuje, že aplikační server byl bezpečnostní politikou skutečně omezen.

Do souboru bezpečnostní politiky dále přidáme přidělení všech oprávnění veškerému kódu běžícímu v rámci aplikačního serveru. Vzniklý soubor bezpečnostní politiky ukazuje ukázka kódu \ref{wildflyPolicy}.

\begin{lstlisting}[caption=První testovací soubor bezpečnostní politiky, label=wildflyPolicy]
grant {
    permission java.security.AllPermission;
};
\end{lstlisting}

Zopakujeme-li experiment, zjistíme že s takto nastavenou bezpečnostní politikou se aplikační server bez problémů spustil a bez problému funguje.
Podrobnějším zkoumáním však zjistíme, že na uživatelské aplikace se tato benevolentní bezpečnostní politika neuplatňuje.
Zatímco zapnutí správce bezpečnosti možnosti uživatelských aplikací skutečně omezilo, nastavení vše povolujících bezpečnostních politik uživatelským
aplikacím žádné z odebraných schopností nenavrátilo.

%=============================================================================
\section{Zavaděč tříd modulů WildFly} \label{moduleClassLoader}
%=============================================================================

Tato podkapitola popisuje jádro problému s bezpečnostními politikami ve WildFly -- zavaděč tříd modulů WildFly ({\tt org.jboss.modules.ModuleClassLoader}).

Zavaděč tříd se podařilo jako viníka odhalit postupným krokováním programu.
To potvrdilo, že objekty bezpečnostní politiky produkují správná oprávnění.
Zároveň ale ukázalo, že do ochranných domén tříd jsou ukládány oprávnění jiná.
Jak vyplývá z popisu cesty oprávnění ze souborů bezpečnostních politik do ochranných domén v kapitole \ref{celkovyPohled},
jediným mezičlánkem, který mohl s oprávněními v této době manipulovat je právě zavaděč tříd.

Toto zjištění se analýzou zdrojového kódu zavaděče tříd modulů potvrdilo -- tento zavaděč oprávnění poskytovaná objektem bezpečnostní politiky implicitně ignoruje.
Namísto toho třídám do ochranných domén ukládá oprávnění určená specifikací Java EE. \cite{javaEEspec}
(Ta jsou případě uživatelských aplikací upravitelná souborem {\tt permission.xml}.)

Nastavením konfigurační proměnné Javy {\tt jboss.modules.policy-permissions} na hodnotu {\tt true} je však možné toto chování změnit.
Bude-li tato konfigurační proměnná takto nastavena, bude tento zavaděč do ochranných domén ukládat jak oprávnění určená specifikací Java EE, tak i oprávnění z objektů bezpečnostní politiky.
Množina oprávnění třídy pak bude odpovídat sjednocení těchto dvou množin oprávnění.
\cite{sourceModuleClassLoader}

\begin{lstlisting}[caption=Úprava spouštěcího skriptu pro spuštění se souborem bezpečnostní politiky, label=jbossOpts]
JAVA_OPTS="$JAVA_OPTS -Djboss.modules.policy-permissions=true"
JAVA_OPTS="$JAVA_OPTS -Djava.security.manager"
JAVA_OPTS="$JAVA_OPTS -Djava.security.policy==directory/wildfly.policy"
\end{lstlisting}

Ukázka kódu \ref{jbossOpts} ukazuje všechny definice konfiguračních proměnných, které je nutné přidat do spouštěcího skriptu aplikačního serveru WildFly,
aby byl spuštěn s oprávněními stanovenými soubory bezpečnostní politiky.

%-----------------------------------------------------------------------------
\subsection{Úpravy zavaděče tříd modulů WildFly} \label{zmenaZaBehu}
%-----------------------------------------------------------------------------

Tato podkapitola popisuje úpravy zavaděče tříd modulů WildFly, které bylo nutné provést, aby bylo možné vyměňovat bezpečnostní politiky za běhu aplikačního serveru.

Jakékoli snahy o výměnu bezpečnostní politiky za běhu aplikačního serveru se doposud jevily jako marné. Oprávnění totiž byly nastavována jako statická,
jsou tedy z objektu bezpečnostní politiky načítána pouze při načítání třídy. Změny bezpečnostní politiky se tak projeví pouze na nově načítaných třídách.

Protože je naším cílem výměna bezpečnostní politiky za běhu aplikačního serveru, je tento stav nedostačující.
Aby byla možná změna bezpečnostní politiky za běhu aplikačního serveru, je nezbytné, aby byla oprávnění používána jako dynamická, jak je popsáno v kapitole \ref{staticPerm}.
V rámci této práce byla tedy vytvořena záplata zavaděče tříd modulů WildFly, která umožňuje používání dynamických oprávnění.

\begin{lstlisting}[caption=Hlavní část záplaty umožňující nastavit používání dynamických oprávnění, label=refreshable]
+  if (POLICY_REFRESHABLE) {
+      protectionDomain = new ProtectionDomain(codeSource, permissions,
+                                 this, null); // staticPermission=false
+  } else if (POLICY_PERMISSIONS && POLICY_READY.get()) {
-  if (POLICY_PERMISSIONS && POLICY_READY.get()) {
\end{lstlisting}

Zatímco řešení popsané v předchozí kapitole ukládalo do ochranných domén množinu oprávnění,
která byla sjednocením oprávnění udělených dle specifikace Java EE a oprávnění z objektu bezpečnostní politiky,
v této variantě jsou do ochranné domény ukládány opět jen oprávnění udělená dle specifikace Java EE.

Při vytváření této ochranné domény je ale použit konstruktor se všemi čtyřmi parametry, čímž je tato doména označena jako používající dynamická oprávnění.
Při každém dotazu na oprávnění k provedení potenciálně nežádoucí operace tak je tento dotaz předán objektu bezpečnostní politiky.

Efektivní oprávnění třídy pak jsou sjednocením dynamických oprávnění z objektu bezpečnostní politiky a statických oprávnění přidělených dle specifikace Java EE při načítání třídy.

Použití této nové varianty bylo přitom záměrně omezeno -- byla vytvořena nová konfigurační vlastnost {\tt jboss.modules.policy-refreshable},
jejíž hodnota určuje, zda má být tato nová varianta použita. Je-li její hodnota {\tt true}, bude použita,
jinak budou oprávnění ve WildFly fungovat tak jako doposud.

Toto omezení bylo do záplaty vloženo záměrně proto, aby bylo možné začlenění této úpravy do vývojové větve WildFly, o což bylo také požádáno \cite{jmPullRequest}.

%=============================================================================
\section{Rozhraní pro správu WildFly} \label{managementAPI}
%=============================================================================

Tato podkapitola popisuje rozhraní umožňující aplikačních serverů WildFly, {\bf JBoss management API}.
Toto rozhraní umožňuje spravovat doménu WildFly a provádět změny v konfiguraci domény i jednotlivých serverů.
\cite{jbossDetypedManagement}

Rozhraní zpřístupňuje konfiguraci ve formě stromové struktury, skládající se z konfiguračních uzlů a konfiguračních vlastností.
Zatímco konfigurační uzly se mohou libovolně zanořovat, vlastnosti mohou být jen listy této stromové struktury.
\cite{jbossDetypedManagement}

Pro reprezentaci dotazů nad touto stromovou strukturou i odpovídajících odpovědí je využívána dynamická reprezentace modelu (DMR -- Dynamic Model Representation).
DMR všechny informace (např. dotaz nebo odpověď Management API) ukládá jako strom uzlů -- objektů třídy {\tt ModelNode}.
\cite{jbossDetypedManagement}

Na rozdíl od uzlů konfiguračního stromu může být obsahem uzlu {\tt ModelNode} hodnota jednoho z definovaných datových typů (viz \cite{jboss7slideShare}) nebo seznam jiných uzlů. Ne však obojí zároveň.
\cite{jboss7slideShare}

Klienti JBoss Management API mohou aplikačnímu serveru pokládat dotazy ve formě uzlů DMR a žádat tak o provedení operace nad konfiguračním stromem.
Výsledek této operace je pak opět ve formě uzlu DMR předán dotazujícímu se klientovi.
\cite{jbossDetypedManagement}

Operace mohou sloužit jak ke čtení dat z konfiguračního stromu a k jejich zápisu, tak i k provádějí jiných akcí souvisejících se správou serverů nebo domény.
Příklady posledního uvedeného typu operace mohou být operace startu ({\tt start}) nebo znovunačtení ({\tt reload}) serveru.
Každý uzel konfiguračního stromu může mít jinou množinu operací, které nad ním lze provádět.
Na tuto množinu operací je možné se serveru dotázat.
\cite{jbossDetypedManagement}

%-----------------------------------------------------------------------------
\subsection{Události v prostředí WildFly} \label{udalostiWildFly}
%-----------------------------------------------------------------------------

Téměř vše co běží v rámci WildFly, včetně jeho součástí, je služba.
Kód služby je prováděn vždy jen v reakci na událost, kterou si služba nějakým způsobem zaregistruje.
Takovou událostí může být například příchod HTTP požadavku s konkrétní URL adresou.
Taková událost může být zaregistrována například Serveletem v rámci jeho definice v konfiguračním souboru Java EE aplikace, {\tt web.xml}.
\cite{jboss7slideShare}

Události typicky registrované součástmi WildFly, jakou je například subsystém, mohou souviset také s konfiguračním stromem popsaným výše.
Mohou tak provádět kód například při vytváření uzlu specifického typu, při jeho odstraňování, při čtení hodnoty jeho vlastnosti nebo při jejím zápisu.
\cite{WildFlyExtending}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Návrh systému} \label{navrh}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Cílem práce je vytvoření systému pro centralizovanou správu a distribuci bezpečnostních politik.
Tento systém by měl umožnit nasazovat bezpečnostní politiky na jednotlivé servery domény WildFly a sledovat také,
které bezpečnostní politiky jsou právě na jednotlivých serverech domény WildFly nasazeny.

Jako příhodné se pro tento účel zdá využití rozšiřitelnosti systému WildFly a implementace formou subsystému aplikačního serveru WildFly.

Subsystém je rozšířením aplikačního serveru, jehož konfigurace i přítomnost je nastavována pro jednotlivé konfigurační profily aplikačního serveru.
(O konfiguračních profilech více v kapitole \ref{uvodWildFly}.)

Optimálním řešením by bylo takové rozšíření WildFly, jež by bylo nasazováno a konfigurováno nezávisle na profilech jednotlivých serverů, na celou doménu.
Takový koncept ale bohužel WildFly neposkytuje.

Dále proto budeme předpokládat, že všechny skupiny serverů, v rámci kterých budeme s bezpečnostními politikami manipulovat, používají stejný profil.
V opačném případě bude nutné konfiguraci bezpečnostních politik provádět pro každý profil zvlášť.

%=============================================================================
\section{Návrh způsobu konfigurace subsystému} \label{zpusobNastaveniJBoss}
%=============================================================================

V této podkapitole je navržen způsob, jakým bude možné komunikovat s implementovaným subsystémem za účelem stanovení bezpečnostních politik, které mají být na jednotlivé servery domény uplatněny.

Pro komunikaci se subsystémy WildFly za účelem správy se typicky využívá rozhraní JBoss management API, popsané v kapitole \ref{managementAPI}.
Subsystém je pak možné nastavovat, sledovat nebo jinak spravovat prováděním operací tohoto rozhraní nad uzly konfiguračního stromu WildFly,
konkrétně jeho podstromu patřícímu tomuto subsystému.
\cite{jbossDetypedManagement}

Jako vhodné se tak jeví využít tento standardní způsob také pro správu v této práci implementovaného subsystému.

Uzel subsystému by tak obsahoval uzly představující jednotlivé servery WildFly domény.
Vlastností každého uzlu serveru by pak byla bezpečnostní politika, jenž by na tomto serveru měla být nasazena.

Možnost nastavit hodnotu konfigurační vlastnosti jako nedefinovanou lze zde s výhodou využít pro stanovení, že správce bezpečnosti nemá být použit.

Samotné nasazování bezpečnostních politik na jednotlivé servery by pak bylo formou události (viz \ref{udalostiWildFly})
navázáno na operaci nastavení hodnoty této konfigurační vlastnosti.

Zmíněná konfigurační vlastnost bude definována se stanoveným objektem ošetřujícím událost změny hodnoty této konfigurační proměnné, který bude zajišťovat
změnu nastavení bezpečnostních politik a správce bezpečnosti.

Pro úplnost je pak nezbytné obdobným způsobem ošetřit také událost vytvoření konfiguračního uzlu serveru, událost jeho odstranění a událost odstranění
celého subsystému.

Bezpečnostní politika nasazená na serveru tak bude vždy odpovídat aktuální hodnotě konfigurační vlastnosti, určující bezpečnostní politiku serveru, uzlu tohoto serveru.

%=============================================================================
\section{Způsob šíření souborů bezpečnostní politiky} \label{sireniSouboru}
%=============================================================================

Jelikož cílem práce není jen centralizovaná správa, ale i distribuce bezpečnostních politik, je nutné stanovit způsob, jakým soubory bezpečnostní politiky budou šířeny mezi servery WildFly domény.

Za pravděpodobně nejjednodušší řešení, které by bylo možné navrhnout, lze označit vytvoření sdíleného adresáře, jež by byl přístupný z každého serveru domény, například prostřednictvím protokolu NFS (Network File System).

S tímto řešením však souvisí hned několik potíží.
První z nich je vyšší platformní závislost -- zatímco WildFly jakožto program v Javě bez problému běží na mnoha platformách a pod různými operačními systémy, protokol NFS není napříč operačními systémy příliš podporován.
Tento problém by bylo možné řešit použitím více rozšířeného protokolu umožňujícího vzdálený přístup k souborům, jakým je například FTP (File Transfer Protocol).

Druhým problém je ale bezpečnost -- protokoly FTP ani NFS samy o sobě nedokáží zaručit autenticitu serveru, ke kterému se klient připojuje.
Případný útočník by se tak mohl vydávat za FTP/NFS server na němž jsou bezpečnostní politiky uložené a podstrčit tak serverům domény vlastní bezpečnostní politiky a sabotovat tím zabezpečení serverů.

Tento problém by mohlo vyřešit použití lépe zabezpečeného protokolu, jakým je například FTPS (FTP over SSL) nebo SSH (Secure Shell), jež umožňuje vzdálený přístup k souborům prostřednictvím SSHFS (SSH Filesystem), kde se server vůči klientovi autentizuje za pomoci asymetrické kryptografie. \cite[3]{ssh}

Použití těchto lépe zabezpečených protokolů zajistí bezpečnost systému, avšak umocní problém platformních omezení, obzvláště v případě protokolu SSH.

Výrazně naroste také problém se zajištěním bezpečnosti takového systému, protože problém bezpečnosti si lze představit jako řetěz.
Tento řetěz je jen tak silný, jak silný je jeho nejslabší článek.
Ačkoli přidání dalšího článku nemusí řetěz oslabit, zvýší se množství článků jejichž sílu bude nutné sledovat.
Z toho vyplývá snaha minimalizovat počet článků tohoto řetězu.

Jako optimální řešení se proto jeví využití existujících kanálů pro přenos informace mezi servery domény.
Takovým kanálem je právě JBoss Management API.

Přenos souborů skrze JBoss Management API je možné snadno implementovat ukládáním obsahu těchto souborů do konfiguračního stromu WildFly.

Implementovaný subsystém by tedy definoval nový typ uzlu konfiguračního stromu, představující soubor bezpečnostní politiky. Jeho vlastností by pak byl obsah souboru bezpečnostní politiky.

Soubory bezpečnostní politiky by pak mohly být nahrávány do konfiguračního stromu na straně doménového řadiče a naopak z nich čteny na straně ostatních členských serverů WildFly domény.

Standardní třída bezpečnostní politiky, {\tt sun.security.provider.PolicyFile}, vyžaduje soubory bezpečnostní politiky přístupné skrze URL adresu souboru.
Je tedy nutné na straně řadových serverů domény bezpečnostní politiku z konfiguračního stromu před jejím nastavením zapsat do dočasného souboru v souborovém systému.

Co však nutné není, je jejich načítání ze souborů v souborovém systému na straně doménového řadiče. Zatímco původní návrh počítal s využitím konfiguračního stromu pouze pro přenos souborů bezpečnostní politiky, ukazuje se jako výhodnější soubory bezpečnostní politiky ukládat přímo do konfiguračního stromu.

Nebude tak třeba ani řešit problém s rozpoznáním, že byl soubor bezpečnostní politiky změněn. Zatímco v souborovém systému by toto bylo nutné řešit periodickým se dotazování na čas poslední změny tohoto souboru, na změnu hodnoty konfigurační vlastnosti není problém skrze událost navázat nové použití bezpečnostní politiky servery domény.

%=============================================================================
\section{Webové uživatelské rozhraní} \label{navrhGUI}
%=============================================================================

Součástí zadání práce bylo také vytvoření webového rozhraní pro komunikaci implementovaného systému s uživatelem.
Jelikož je samotné jádro řešení implementováno jako subsystém WildFly, jako logické řešení se nabízí implementovat uživatelské rozhraní tohoto subsystému jako rozšíření webové konzoly WildFly.

Webová konzola WildFly je standardní součástí aplikačního serveru WildFly. Je GWT (Google Web Toolkit) aplikací běžící na straně klienta, ve webovém prohlížeči.
Aplikační server tato aplikace spravuje prostřednictvím HTTP varianty JBoss Management API.
Tato varianta Management API běží nad protokolem HTTP a tělem POST dotazů klienta i tělem odpovědí serveru je JSON reprezentace uzlu DMR (blíže popsaném v kapitole \ref{zpusobNastaveniJBoss}).
\cite{WildFlyManagementAPIreference}

Grafická podoba uživatelského rozhraní, jak byla ve fázi návrhu systému navržena, konkrétně části umožňující samotné nastavení bezpečnostní politiky na jednotlivých serverech a skupinách serverů, je vyobrazena na obrázku \ref{navrhGui}.

Pro srovnání je zároveň na obrázku \ref{vysledneGui} ukázán snímek obrazovky zachycující podobu této části uživatelského rozhraní, jak bylo nakonec implementováno.

Celkově se rozšíření webové konzoly WildFly skládá z následujících tří konfiguračních obrazovek:

\begin{enumerate}
  
  \item Obrazovka {\bf Servers} (Servery) byla již zmíněna a umožňuje zvolit bezpečnostní politiku jednotlivých serverů a skupin. Umožňuje tedy spravovat konfigurační uzly {\tt server=*}.
  
  \item Obrazovka {\bf Policies} (Politiky) umožňuje vytvářet a nastavovat samotné bezpečnostní politiky, které pak mohou být jednotlivým serverům přidělovány na obrazovce {\bf Servers}. Umožňuje tedy spravovat konfigurační uzly {\tt policy=*}.
  
  \item Obrazovka {\bf JSM Policy} (JSM Politika) umožňuje zobrazit bezpečnostní politiku nasazenou na vybraném serveru -- její název a obsah.
  
\end{enumerate}

\begin{figure}[ht]
  \centering
  \includegraphics[width=14cm]{fig/mockup}
  \caption{Grafický návrh uživatelského rozhraní plánovaného rozšíření WildFly.}
  \label{navrhGui}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=14cm]{fig/jsmpolicy-servers}
  \caption{Výsledná podoba webového uživatelského rozhraní.}
  \label{vysledneGui}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Popis implementace systému} \label{implementace}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\section{První etapa}
%=============================================================================

V rámci první etapy řešení byl implementován jednoduchý subsystém WildFly za pomoci kostry subsystému z Maven repozitáře, podle dokumentace WildFly 8 věnující se právě vytváření rozšíření WildFly. \cite{WildFlyExtending}

Dle tohoto vzoru byl vytvořen subsystém, jehož jedinou funkcí bylo rozšíření konfiguračního stromu o uzly {\tt server=*} uchovávající informaci o URL souborů bezpečnostních politik.
Ty by měly být uloženy na jednotlivých serverech domény WildFly.
Tyto uzly fungovaly jako většina typů uzlů konfiguračního stromu WildFly -- administrátor měl možnost je vytvářet, odstraňovat a nastavovat jejich vlastnost {\tt policy}, jež nesla právě samotnou URL nasazené bezpečnostní politiky.

Na změnu této konfigurační vlastnosti server domény daný jménem uzlu reagoval nasazením dané bezpečnostní politiky.

Toho bylo dosaženo registrací události zápisu do této konfigurační vlastnosti při její definici.
Byla tedy vytvořena třída {\tt ServerWriteAttributeHandler}, jejíž instance byla uvedena při registraci konfigurační vlastnosti {\tt policy}:

\begin{lstlisting}[caption=Registrace konfigurační vlastnosti {\tt policy} uzlu {\tt server=*}, label=registraceAtributu]
resourceRegistration.registerReadWriteAttribute(POLICY,
                null, ServerWriteAttributeHandler.INSTANCE);
\end{lstlisting}

Nebyla stanovena třída zprostředkovávající čtení tohoto konfigurační vlastnosti. (Na jejím místě je uveden {\tt null}) Čtení této konfigurační vlastnosti tak nebylo spojeno s žádnou další akcí.

Aby byla bezpečnostní politika aplikována nejen na základě akce administrátora, ale také automaticky při startu serveru, bylo její použití navázáno také na akci přidání nového uzlu {\tt server=*}.

Na odstranění tohoto uzlu by zároveň mělo být navázáno odebrání bezpečnostní politiky, stejně jako při nastavení hodnoty vlastnosti {\tt policy} na nedefinovanou.

Pro dosažení provádění obou zmíněných navázaných akcí byly implementovány třídy {\tt ServerAdd} a {\tt ServerRemove}.
Ty jsou na uzly typu {\tt server=*} navázány při definici těchto konfiguračních uzlů v subsystému:

\begin{lstlisting}[caption=Definice konfiguračního uzlu {\tt server=*}, label=registraceUzluServer]
public class ServerDefinition extends SimpleResourceDefinition {
    private ServerDefinition() {
        super(JsmPolicyExtension.SERVER_PATH,
                JsmPolicyExtension.getResourceDescriptionResolver("server"),
                ServerAdd.INSTANCE,
                ServerRemove.INSTANCE);
    }
}
\end{lstlisting}

Konfigurační uzly {\tt server=*} jsou ukládány do konfiguračního XML souboru domény WildFly, jak je u konfigurační uzlů WildFly běžné.
Ukládání veškeré konfigurace subsystému je implementováno ve třídě {\tt SubsystemParser}, jak je tomu u vzorového subsystému \cite{WildFlyExtending}.

%=============================================================================
\section{Druhá etapa}
%=============================================================================

V rámci druhé etapy bylo uživatelské rozhraní pozměněno dle grafického návrhu předvedeného v kapitole \ref{navrhGUI}. V souvislosti s touto změnou bylo nutné rozšířit rovněž subsystém WildFly. Jeho dosavadní implementace neumožňovala výběr bezpečnostní politiky formou výběru v rozbalovací nabídce.

Výběr formou rozbalovací nabídky vyžaduje od aplikace zobrazující nabídku znalost voleb, mezi nimiž může uživatel provádět výběr.
To při dosavadní implementaci subsystému možné nebylo, neboť aplikace běžící na straně webového prohlížeče k souborům na serveru přímo přistupovat nemůže.
Dosavadní implementace subsystému přístup k seznamu zvolitelných souborů bezpečnostní politiky také neumožňovala.

Do části konfiguračního stromu náležející subsystému tak vedle dosavadních uzlů {\tt server=*} přibyly uzly {\tt policy=*}.
Ty reprezentovaly jednotlivé soubory, které bylo možné jako soubory bezpečnostní politiky jednotlivých serverů nastavit.

Tyto uzly nebyly ukládány do konfiguračního XML souboru aplikačního serveru.
Byly vytvářeny subsystémem při startu aplikačního serveru na základě obsahu adresáře určeného pro soubory bezpečnostních politik.

Sdílení tohoto adresáře napříč jednotlivými server domény bylo nezbytné zajistit jinou cestou. (Tento problém je podrobněji popsán v kapitole \ref{sireniSouboru}.)

Dodatečně odhaleným nedostatkem byla absolutní cesta k souboru bezpečnostní politiky v konfigurační vlastnosti {\tt policy}.
Výrazně tak byla zkomplikována možnost ostrého nasazení systému v případě domény více hostitelů.

%=============================================================================
\section{Třetí etapa}
%=============================================================================

V rámci třetí etapy byl subsystém WildFly upraven, aby konfigurační strom WildFly nefungoval jen jako úložiště adres nastavených bezpečnostních politik, ale také jako úložiště samotných bezpečnostních politik.

Byl tedy pozměněn význam konfigurační vlastnosti {\tt file} uzlu {\tt policy=*}. Absolutní URL adresa souboru bezpečnostní politiky byla nahrazena obsahem souboru bezpečnostní politiky.

Zároveň byl změněn význam konfigurační vlastnosti {\tt policy} uzlu {\tt server=*}, jež doposud rovněž obsahoval URL adresu souboru bezpečnostní politiky nasazené na daném serveru.
Nově obsahoval název uzlu {\tt policy=*}, jehož hodnota atributu {\tt file} měla být použita jako soubor bezpečnostní politiky pro daný server.

Nadále tak nestačilo provádět aplikaci bezpečnostní politiky při změně atributu {\tt policy} uzlu {\tt server=*}, ale bylo nutné bezpečnostní politiku používanou aplikačním serverem znovu nastavit také při změně obsahu vlastnosti {\tt file} uzlu {\tt policy=*}.

Toto je řešeno analogicky jako právě v případě akce navázané na změnu vlastnosti uzlu serveru -- vytvořením třídy {\tt PolicyWriteAttributeHandler} a jejím navázáním na vlastnost uzlu bezpečnostní politiky při její definici.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Testování systému} \label{testovani}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Protože cílem této bakalářské práce nebylo jen vytvoření systému umožňujícího správu bezpečnostních politik nasazených na jednotlivých serverech distribuovaného systému, ale také jeho otestování, tato kapitola se zabývá tvorbou testů, umožňujících otestovat implementované řešení.

Testování je nedílnou součástí vývoje software a je užíváno k odhalení vad software a prokázání, že software dosáhl požadované úrovně kvality v zadaných kritériích. Obvykle se provádí za pomoci automatizovaných programů, takzvaných testů. \cite{ivsTest}

Testy se běžně dělí následovně: \cite{testsTypes}\cite{ivsTest}

\begin{enumerate}
  
  \item {\textbf Jednotkové testy (Unit tests)} testují jednotlivé jednotky systému. Jednotkou je typicky třída programovacího jazyka. Každá jednotka se testuje samostatně, s maximální snahou o izolaci od ostatních součástí systému. Jejich cílem je především ověřit, zda jednotlivé jednotky splňují svoji specifikaci -- dodávají na základě testovacího vstupu odpovídající výstup. Nijak neřeší problémy v komunikaci jednotlivých jednotek mezi sebou nebo se zbytkem systému (v tomto případě aplikačním serverem WildFly). \cite{testsTypes}\cite{ivsTest}
  
  \item {\textbf Systémové testy (System tests)} testují celý systém jako jediný celek a umožňují ověřit zda systém jako celek dokáže plnit svůj účel, pro který byl vytvořen. Testovaný systém ovlivňují a kontrolují zpravidla z jeho vnějšku. \cite{testsTypes}\cite{ivsTest}
  
  \item {\textbf Integrační testy (Integration tests)} jsou mezistupněm mezi jednotkovými a systémovými testy. Jak jejich název napovídá, jejich hlavním účelem je ověřit zda spolu testované jednotky správně spolupracují. \cite{testsTypes}\cite{ivsTest}
  
\end{enumerate}

Protože lze systémové testy někdy chápat také jako zvláštní případ integračních testů, jsou systémové testy někdy mezi integrační testy zahrnovány. \cite{testsUnitVsInteg}

%=============================================================================
\section{Jednotkové testy}
%=============================================================================

Jednotkové testy tedy umožňují testovat jednotlivé jednotky systému a těmito jednotkami, po kterých se systém testuje, jsou typicky třídy programovacího jazyka. Každé třídě programu by v ideálním případě měla být přidělena jedna třída testu, jež by měla ověřit správnost fungování této třídy. \cite{ivsTest}

Testované jednotky by měly být testovány ve vzájemné izolaci. Toho se dosahuje buď jejich vhodným návrhem, nebo použitím napodobenin objektů ({\it mock object}) z jiných jednotek, na kterých tato jednotka závisí. \cite{ivsTest}

Komplikace jež by mohly ohrozit samotnou výměnu bezpečnostní politiky nebo správce bezpečnosti vyplývají převážně z integrace s aplikačním serverem WildFly. Vytvoření jednotkových testů pro výměnu bezpečnostní politiky a správce bezpečnosti by tedy nebylo příliš užitečné.

Byly však vytvořeny jednotkové testy pro testování podpůrných součástí implementovaného subsystému -- testy syntaktické kontroly souborů bezpečnostní politiky, práce s částí konfiguračního strom DMR náležející implementovaného subsystému a načítání části konfiguračního souboru WildFly náležející subsystému.

%=============================================================================
\section{Integrační testy}
%=============================================================================

Integrační testy testují systém jako celek. Implementovaný systém byl tímto způsobem testován na schopnost plnění základních požadavků daných zadáním této práce -- schopnosti zapnout a vypnout správce bezpečnosti a vyměnit používanou bezpečnostní politiku skrze JBoss Management API.

Byl tedy vytvořen integrační test umožňující otestovat zmíněné schopnosti na běžícím aplikačním serveru WildFly s nainstalovaným subsystémem pro nastavení bezpečnostní politiky, jehož vytvoření je popsáno v kapitole \ref{implementace}.

Tento test se skládá ze dvou částí -- agenta, aplikace nasazované na testovaný server, a manažeru -- testu vytvořeného za pomoci knihovny JUnit, řídícího proces samotného testování.

{\it Agent} je Java EE aplikací nabízející své služby skrze rozhraní REST. Službami, jež poskytuje, je zejména otestování schopnosti provést vybranou akci z pozice aplikace nasazené na testovaném serveru. Klient rozhraní REST se tedy k této službě může připojit a požádat o otestování schopnosti provést vybranou operaci. Jako odpověď pak dostane informaci, zda-li se provedení této operace zdařilo, nebo zda bylo zmařeno Access controllerem.

Mimo toho tato služba umožňuje manageru zjistit také některé další informace o aplikačním serveru, zjistitelné ze strany aplikace nasazené na tomto aplikačním serveru, jako je aktuálně používaná třída security manageru, používaná třída bezpečnostní politiky, nebo samotná přítomnost agenta na testovaném aplikačním serveru.

{\it Manager} je část systémového testu běžící mimo aplikační server. Sestává z testů založených na knihovně JUnit a pomocných tříd {\tt Domain} a {\tt Server}.

Třída {\tt Server} zajišťuje komunikaci manageru s agentem nasazeným na testovaném serveru WildFly prostřednictvím protokolu REST. Některé testy, například testy vzájemného ovlivňování serverů mezi sebou, mohou vyžadovat monitoring více serverů WildFly najednou. Na každém z nich pak musí být nasazena aplikace agenta a s každým z nich pak bude moci test komunikovat prostřednictvím samostatné instance třídy {\tt Server}.

Třída {\tt Domain} mezitím zajišťuje komunikace se samotnou doménou aplikačních serverů prostřednictvím protokolu JBoss Native API. Umožňuje manipulovat s konfiguračním stromem WildFly, zejména přidávat a upravovat hodnoty konfiguračních vlastností uzlů {\tt server=*} a {\tt policy=*} a tím nasazovat bezpečnostní politiky na jednotlivé servery WildFly domény.

Určitý problém, jež bylo nutno vyřešit, zde představuje způsob, jakým po skončení každého testu navrátit systém do původního stavu. Jelikož se jedná o testování z vně aplikačního serveru, není pro tento účel možné využít operaci {\tt rollback}, jež se běžně automaticky provádí při selhání objektu ošetřujícího událost úpravy konfiguračního uzlu.

Budeme-li však předpokládat že testy budou prováděny na k tomu určené doméně aplikačních serverů, můžeme pominout požadavek na navrácení původní konfigurace po ukončení testování a omezit navrácení do původního stavu na navrácení do stavu s prázdným konfiguračním uzlem subsystému, tedy bez jakýchkoli konfiguračních uzlů 
{\tt server=*} nebo {\tt policy=*}.

Další operací objektu domény tak bude navrácení subsystému do počátečního stavu. Toho bude dosaženo spojením operace odstranění uzlu subsystému {\tt jsmpolicy} konfiguračního stromu a jeho opětovné přidání.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Závěr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Cílem práce bylo navrhnout, vytvořit a otestovat systém pro centralizovanou správu a distribuci bezpečnostních politik Javy v distribuovaném prostředí aplikačního serveru WildFly.

Ačkoli jen samotné používání bezpečnostní politiky ve WildFly bylo v době tvorby této práce bez úpravy zdrojového kódu nemožné (viz kapitola \ref{jboss}),
bylo v rámci této bakalářské práce umožněno nejen používání bezpečnostní politiky, ale také její výměna za běhu aplikačního serveru bez potřeby
jeho restartu nebo znovunačtení.

Dosaženo toho bylo za pomoci několika záplat ({\it patch}) součástí WildFly (viz kapitola \ref{jboss}), přičemž obecnější z nich byly předány
k začlenění do hlavní vývojové větve. \cite{smPullRequest}\cite{jbossModulesPullRequest}

O začlenění nebylo zažádáno pouze v případě záplaty správce bezpečnosti WildFly umožňující povolení nastavování správce bezpečnosti,
zejména pro potřeby jeho vypínání, protože porušovala původní návrh této součásti WildFly.

Po vyřešení samotného používání a výměny bezpečnostních politik v prostředí aplikačního serveru WildFly bylo vytvořeno rozšíření aplikačního serveru.

To umožňuje provádět výměnu používané politiky a zapínat/vypínat správce bezpečnosti v návaznosti na změnu konfigurace pro příslušný server
v konfiguračním stromu WildFly.

Konfigurační strom WildFly se zároveň používá také pro ukládání jednotlivých souborů bezpečnostní politiky, které jsou tímto způsobem distribuovány napříč aplikačními servery domény.

Nad tímto rozšířením aplikačního serveru pak bylo vytvořeno webové uživatelské rozhraní ve formě rozšíření webové administrační konzoly WildFly.
To umožňuje nastavovat použití správce bezpečnosti a nastavovat bezpečnostní politiky na jednotlivých serverech nebo celých skupinách serverů WildFly domény.

Na implementované řešení byla nakonec vytvořena automatizovaná sada testů umožňující otestovat schopnost implementovaného systému měnit oprávnění
aplikací nasazených na aplikačním serveru nebo v doméně aplikačních serverů.

