%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Jan Kalina <xkalin03@stud.fit.vutbr.cz> 2013
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Bezpečnost v Javě}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\section{Bezpečnost}
%=============================================================================

Protože se tato práce zabývá bezpečností, což je pojem, který lze v různých souvislostech chápat zcela odlišně, je nanejvýš vhodné nejprve specifikovat co termínem bezpečnosti míníme a z kterého pohledu se jí budeme zabývat.

Scott Oaks definuje ve své knize Java Security bezpečnost jako souhrn následujících kritérií: \cite[1.1]{oaks}

\begin{itemize}
  \item Bezpečí vůči zákeřnému software - programy by neměly být schopny poškodit prostředí hostitelského počítače.
  \item Bezpečí vůči Velkému bratru - programům by mělo být bráněno ve šmírování uživatele -- programy by neměly být schopny svévolně číst soukromé informace na počítači na kterém běží, ani na síti ke které je tento počítač připojen.
  \item Autentizace - identita autorů programu by měla být ověřována (typicky pomocí elektronickému podpisu).
  \item Šifrování - data odesílaná a přijímaná programem by měla být šifrována.
  \item Auditovatelnost - potenciálně škodlivé operace by měly být vždy zaznamenávány.
  \item Specifikovanost - program by měla doprovázet specifikace bezpečnostních pravidel, které program dodržuje.
  \item Verifikovanost - pro prováděné operace by měla být stanovena pravidla, proti kterým by měly být verifikovány.
  \item Dbaní na dobré vychování - programům by mělo být bráněno v užívání příliš mnoha systémových prostředků.
\end{itemize}

V souvislosti s víceuživatelskými prostředími se pak pojem bezpečnosti vyskytuje ještě v další rovině, kdy nejde o bezpečí před běžícím programem, ale o způsob jakým může naopak program ověřit, kdo je jeho uživatelem a zdali má právo po něm žádat vykonání operace, o jejíž vykonání žádá.

V této práci se však budeme zabývat bezpečností ve smyslu prvních tří uvedených kritérií, tedy ve smyslu ochrany prostředí a dat hostitele před programy.

%=============================================================================
\section{Java}
%=============================================================================

Programy v jazyce Java bývají překládány do platformě nezávislého a efektivněji než kód v jazyce Java interpretovatelného mezikódu, takzvaného bytekódu.
Bytekód bývá zpravidla interpretován virtuálním strojem Javy (JVM - Java Virtual Machine).
JVM je abstraktní výpočetní stroj. Podobně jako reálné výpočetní stroje má svoji instrukční sadu a paměť se kterou může manipulovat, ale na rozdíl od nich pro něj neexistuje jeho fyzická implementace, pouze emulovaná implementace softwarová.
To znamená že její kód není prováděn nativně hardwarem, ale je interpretován speciálním programem, interpreterem, který je sám zkompilován do nativního kódu dané platformy.
To mimo nezávislosti na platformě přináší také vyšší stupeň abstrakce.

Díky tomu, že programy nepřistupují ani nemohou přistupovat ke zdrojům fyzického stroje přímo, ale pouze zprostředkovaně skrze zdroje virtuální stroje Javy, si není těžké představit, že by použití takovéhoto virtuálního stroje mohlo mít i významný bezpečnostní efekt.
Protože programy v JVM mohou k fyzickým zdrojům počítače (např. k souborům nebo k síti) přistupovat jen skrze JVM, zablokování takového přístupu ze strany JVM není nikterak složité - JVM stačí odmítnout takový požadavek a interpretovaný program nemá možnost JVM obejít.

%=============================================================================
\section{Java Security Manager}
%=============================================================================

Pro maximální nastavitelnost omezení kladených na programy běžících na virtuáních strojích Javy nerozhoduje o povolení nebo zablokování operace nad zdrojem JVM samotná JVM, ale dotazuje se speciálního objektu třídy {\tt java.lang.SecurityManager}, nebo jeho podtřídy.

Podtřída je třída dědící atributy a metody (operace, přijímané zprávy) své nadtřídy a reference na její instanci může být vložena do proměnné určené pro referenci na její nadtřídu. Jakákoli podtřída třídy SecurityManager tedy bude vždy přijímat všechny zprávy, které přijimá třída SecurityManager, přičemž ty, které nebude sama implementovat, budou přejaty z její nadtřídy SecurityManager.

Security manager, který JVM použije při svém startu lze ovlivnit skrze konfigurační proměnnou JVM -- {\tt java.security.manager}. Za běhu je možné aktuálně používaný Security manager zjistit voláním {\tt System.getSecurityManager() } a vypnout nebo vyměnit voláním {\tt System.setSecurityManager()}. Volání těchto metod bývá samo chráněno Security managerem, takže nehrozí že by se program neoprávněně zbavil omezení, které na něj uvalil Security manager vypnutím nebo vyměněním Security manageru.

Hodnotu konfigurační proměnné {\tt java.security.manager} po startu JVM je možné nastavit za pomoci k tomu určeného parametru {\tt -D}. Pro spuštění programu s výchozím Security managerem můžeme tedy použít příkaz:

\begin{verbatim}
java -Djava.security.manager=default ProgramABC
\end{verbatim}

Základní možné hodnoty proměnné {\tt java.security.manager} a jim odpovídající třídy objektů security managera popisuje následující tabulka.

\begin{center}
    \begin{tabular}{| l | l |}
    \hline
    Parametr příkazu java & Použitý JSM \\ \hline
    (parametr nepoužit)                                      & {\tt null                      } \\
    {\tt -Djava.security.manager                           } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=default                   } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=java.lang.SecurityManager } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=TestovaciSM               } & {\tt TestovaciSM               } \\
    \hline
    \end{tabular}
\end{center}

Poslední řádek demonstruje použití vlastní třídy objektu security managera. Způsob vytvoření vlastního Security manageru bude podrobněji rozebrán v další kapitole. Jestliže je zde uvedena neexistující třída, skončí inicializace JVM vyjímkou a vykonávání programu nebude vůbec zahájeno:

\begin{verbatim}
Error occurred during initialization of VM
java.lang.InternalError: Could not create SecurityManager: neexistujici.SM
    at sun.misc.Launcher.<init>(Launcher.java:106)
    at sun.misc.Launcher.<clinit>(Launcher.java:57)
    at java.lang.ClassLoader.initSystemClassLoader(ClassLoader.java:1486)
    at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1468)
\end{verbatim}

Tím že je zabráněno startu JVM v případě chybné konfigurace Security manageru -- je tedy uplatněn bezpečnostní princip, podle kterého musí systém zůstat bezpečný i v případě poruchového stavu.

%=============================================================================
\section{Implementace vlastního Security manageru}
%=============================================================================

V této podkapitole bude vysvětlen způsob stanovení bezpečnostní politiky vytvořením vlastního Security manageru.
Security manager je objekt, na který JVM při požadavku Java API deleguje rozhodnutí o povolení nebo nepovolení operace nad zdrojem.
Tento objekt je instancí třídy {\tt java.lang.SecurityManager} nebo její podtřídy.
Algoritmus používaný Java API pro rozhodnutí o vykonání nebo nevykonání potenciálně nebezpečné operace je následující: \cite[4.1.1]{oaks}

\begin{enumerate}
  \item Uživatelská aplikace žádá Java API o provedení dané operace
  \item Java API se dotáže Security manageru zda operaci povolit zavoláním patřičné metody Security manageru.
  \item Nemá-li být operace povolena, vrátí Security manager vyjímku {\tt SecurityException}, která je předána uživatelské aplikaci, čímž je vykonání operace zabráněno.
  \item Není-li vyhozena žádná vyjímka, operace se považuje za povolenou a je provedena.
\end{enumerate}

Vlastní Security manager tedy vytvoříme rozšířením třídy {\tt SecurityManager}, přičemž přepíšeme metody rozhodující o povolení akce, kterou chceme povolit, nebo pro kterou chceme stanovit vlastní algoritmus rozhodující zda akci povolit nebo ne.
Protože standardní Security manager implicitně všechny operace zakazuje, stačí nám implementovat metody autorizující provedení operací, které chceme povolit a operacemi které nikdy povolit chtít nebudeme se nebudeme muset zabývat.

Příklad níže ukazuje jednoduchý Security manager, který o povolení každé akce rozhodne na základě interakce s uživatelem. Při pokusu programu o provedení potenciálně nebezpečné operace je uživateli zobrazen dotaz, zda chce tuto operaci povolit nebo ne. V případě negativní odpovědi je jejímu provedení vrácením vyjímky {\tt SecurityException} zabráněno.

\begin{verbatim}
public class TestovaciSM extends SecurityManager {
    @Override
    public void checkPermission(Permission permission) {
        
        System.out.println("Povolit " + permission.toString() + " ?");
        if(!askUser()){ // jestliže uživatel nezvolí "ano"
            throw new SecurityException("Operace byla zakázána uživatelem");
        }
        
    }
}
\end{verbatim}

Takto vytvořený Security manager pak můžeme na vlastní program nechat použít za pomoci dříve zmíněného příkazu:

\begin{verbatim}
System.setSecurityManager(new TestovaciSM());
\end{verbatim}

Jinak (pro libovolný program) můžeme použití tohoto Security manageru nastavit při startu JVM:

\begin{verbatim}
java -Djava.security.manager=TestovaciSM HelloWorld
\end{verbatim}

Nutno dodat že tato konfigurační proměnná je uplatněna při startu JVM, její změnou za běhu JVM nebude použití Security manageru ovlivněno.

Zde uvedený Security manager je opravdu pouze demonstrativní, v čemž se můžeme utvrdit, spustíme-li jej nad jednoduchou aplikací Hello world. Množství dotazů kladených na Security manager je i u takto primitivní aplikace příliš velké, než aby je bylo možné nechat zodpovědět uživatelem.

Stanovení bezpečnostní politiky vytvořením Security manageru ale nepochybně možné je. Vyžaduje ale znalosti programování v Javě od správce počítače na němž JVM běží a od Javy verze 2 se již pro stanovení bezpečnostní politiky nepoužívá.

%=============================================================================
\section{Zavaděče tříd}
%=============================================================================

Než se dostaneme k v současnosti využívanému způsobu stanovování bezpečnostní politiky, pozastavíme se nad tématem zavádění tříd.
Ačkoli se na první pohled může zdát, že toto téma s bezpečností příliš nesouvisí, opak je pravdou.
Jen a pouze zavaděč tříd (classloader), který třídu do paměti zavádí totiž může určit původ třídy, od kterého se oprávnění kódu této třídy odvozuje.

Zavaděč je objekt odpovědný za načítání tříd a rozhraní v Javě. Na základně binárního názvu třídy (tedy názvu používaného v bytekódu, např. {\tt java.lang.String} nebo {\tt java.security.KeyStore\$Builder\$FileBuilder\$1}) se pokusí vyhledat a načíst třídu daného názvu. \cite{refClassLoader}

Třída každého zavaděče musí být podtřídou třídy {\tt java.lang.ClassLoader} a musí implementovat metodu {\tt findClass()}, která provádí právě samotné vyhledání třídy podle názvu. Jejím výstupem je objekt třídy {\tt Class} představující samotnou třídu. Při programování běžných aplikací můžeme na objekty této třídy narazit například při snaze získat název třídy neznámého objektu jako řetězec za běhu aplikace: \cite{refClassLoader}

\begin{verbatim}
Class tridaObjektuX = x.getClass();
String nazevTridyObjektuX = c.getName();
\end{verbatim}

Každý objekt v Javě si totiž uchovává referenci na svoji třídu, již zmíněný objekt třídy {\tt Class}, obsahující mimo jiného také právě název třídy ve formě textového řetězce.

Jako původ třídy ({\tt CodeSource}) souhrně označujeme URL adresu, ze které byla třída získána, a elektronické podpisy, kterými přitom byl její JAR archiv opatřen.
Na základě původu je třída zařazena do ochranné domény. Mají-li dvě třídy stejný původ, je jim přiřazena stejná ochranná doména. \cite[5.1]{oaks}\cite{sourceSecureClassLoader}

Ochranná doména ({\tt ProtectionDomain}) je uskupení zdrojových kódů a oprávnění, které jsou tomuto kódu udělena.
Speciálním případem je tzv. systémová ochranná doména, do které spadají třídy zavedení interním zavaděčem tříd (viz. \ref{interniZavadec}), jejiž reference na ochrannou doménu je nastavena na {\tt null} a jejich oprávnění nejsou omezené. \cite[5.4]{oaks}

%-----------------------------------------------------------------------------
\subsection{Interní zavaděč tříd} \label{interniZavadec}
%-----------------------------------------------------------------------------

Interní zavaděč tříd je zavaděč používaný pro načítání tříd samotného Java API a zavaděčů uživatelských tříd.
Interní zavaděč je součástí JVM. Je napsán převážně v nativním kódu a k načítání tříd využívá nativní metody pro přístup k souborovému systému operačního systému.
Interní zavaděč načítá třídy ze souborů, jejiž adresu odvozuje z názvu třídy, balíčku a proměnné prostředí CLASSPATH. \cite[3.2.1]{oaks}

Je-li tedy JVM spuštěna následujícím příkazem:

\begin{verbatim}
java -classpath /srv/classes muj.program.Test
\end{verbatim}

Bude spuštěna metoda {\tt main()} třídy {\tt Test}, jež bude hledána v souboru:

\begin{verbatim}
/srv/classes/muj/program/Test.class
\end{verbatim}

O třídách načtených interním zavaděčem se často mluví jako o třídách bez zavaděče, protože jejich objekt {\tt Class} má referenci na zavaděč nastavenu na {\tt null}. \cite[3.2.1]{oaks} Zároveň je {\tt null}ová také ochranná doména takto načtených tříd. Třídy načtené interním zavaděčem tak nemají svá oprávnění omezena.

Interní zavaděč je v současnosti používán k načítání jen nejzákladnějších tříd, zejména tříd Java API, tedy tříd používajících součásti napsané v nativním kódu. Ostatní třídy z {\tt CLASSPATH} jsou obvykle načítány Zavaděčem tříd z URL.

%-----------------------------------------------------------------------------
\subsection{Zavaděč tříd z URL}
%-----------------------------------------------------------------------------

Zavaděč tříd z URL ({\tt URLClassLoader}) hledá třídy také na URL adresách určených polem objektů {\tt URL}, předaných jeho kontruktoru. Je jedním z nejpoužívanějších zavaděčů tříd v Javě -- používá se i k vyhledávání méně základních tříd z {\tt CLASSPATH} a dokáže třídy načítat nejen z adresářů, ale i z JAR archivů, je-li jako adresa uvedena adresa JAR archivu. \cite[3.2.5]{oaks}

\begin{verbatim}
URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{
    new URL("http://server/directory/"),
    new URL("file:/srv/classes/")
}, parentClassloader);
\end{verbatim}

Zavaděč tříd z URL je jedním z bezpečných zavaděčů ({\tt SecureClassLoader}). To znamená že automaticky nastavuje ochranou doménu třídám, které načítá.
Ochranná doména která bude zvolena závisí na následujících parametrech: \cite{refPolicyFiles}

\begin{itemize}
  \item {\tt codeBase}: URL adresa ze které byla třída načtena.
  \item {\tt signedBy}: Alias podpisu, kterým byl JAR archiv z něhož byla třída načtena podepsán.
  \item {\tt principal}: Operaci žádá kód spuštěný uživatelem s oprávněním uvedeným v pravidlu bezpečnostní politiky.
\end{itemize}

Třídy, které mají všechny tyto parametry společné, patří do stejné ochranné domény a mají tak stejná oprávnění.

%=============================================================================
\section{Access Controller a soubory bezpečnostní politiky}
%=============================================================================

Access controller je mechanismus využívající ochranné domény tříd, který standardní Security manager (od Javy verze 2) využívá pro rozhodnutí, zda operaci požadovanou uživatelským programem povolit či nikoliv. Aby tedy byla aplikována omezení stanovená Access controller, musí být JVM spuštěna se standardním Security managerem. \cite[5]{oaks}

Access controller, stejně jako Security manager, umožňuje omezit, zdali může být operace nad zdrojem provedena nebo ne. Zdroji zda však již nejsou jen zdroje samotné JVM. Access controller mohou využívat i uživatelské procesy pro omezení přístupu ke zdrojům, které poskytují. \cite[5]{oaks}

Máme-li tedy knihovní třídu zprostředkovávající přístup k databázi v souboru po záznamech, při použití oprávnění jen na úrovni Java API by bylo možné programu přidělovat oprávnění jen k celému souboru. Access controller ale umožňuje považovat jednotlivé záznamy databáze v souboru za samostatné zdroje, čímž umožňuje různým programům přidělit oprávnění jen k vybraným záznamům v databázovém souboru.

Access controller je schopný pravidla bezpečnostní politiky načítat z textového konfiguračního souboru -- tzv. souboru bezpečnostní politiky. Vzniká tak mnohem snazší způsob stanovení bezpečnostní politiky, kterou budou programy v JVM omezeny -- namísto tvorby vlastní třídy Security manageru bude pro stanovení bezpečnostní politiky stačit upravovat obsah souboru bezpečnostní politiky. \cite[5]{oaks}

Ochraná doména (Protection Domain) je uskupení zdrojových kódů a oprávnění, které jsou tomuto kódu udělena. Každá třída spadá vždy do jedné ochrané domény, která jí je přidělena zavaděčem při jejím načítání. Jen zavaděč totiž zná původ třídy, na základě kterého jsou třídy ochraným doménám přidělovány. Speciálním případem jsou třídy zavedené interním zavaděčem (viz. \ref{interniZavadec}), které spadají do systémové ochrané domény a mají tak vždy povoleno vše. \cite[5.4]{oaks}

Access controller rozhoduje o povolení nebo nepovolení operace na základně průniku oprávnění ochraných domén tříd metod, jež vedly k zavolání metody provádějící citlivou operaci a dotazující se na její legálnost Access controlleru, ať už přímo nebo skrze Security manager.

%-----------------------------------------------------------------------------
\subsection{Implementace Access Controlleru}\label{implementaceAC}
%-----------------------------------------------------------------------------

Access controller je implementován třídou {\tt AccessController} a voláním jeho statických metod na něj standardní Security manager deleguje rozhodnutí o legálnosti provedení potenciálně nežádoucí operace uživatelského programu. Konkrétně kontrolu obstarává metoda {\tt checkPermission(Permission)}, která v případě neoprávněnosti požadavku na provedení operace způsobí vyhození vyjímky {\tt AccessControlException}. Jejím vstupem je objekt třídy {\tt Permission}, která reprezentuje oprávnění, jehož vlastnictví je testováno. \cite[5.5]{oaks}\cite[6]{oaks}

Následující příklad ukazuje způsob, jakým se může kód dotázat Access controlleru, zdali má zadané oprávnění: \cite[5.5]{oaks}

\begin{verbatim}
try {
    // má tento program oprávnění připojit se na lokální port 80?
    AccessController.checkPermission(
        new SocketPermission("localhost:80", "connect")
    );
    System.out.println("Program má oprávnění připojit se na port");
} catch (AccessControlException ace) {
    System.out.println("Program nemá oprávnění připojit se na port");
}
\end{verbatim}

Access controller rozhoduje o povolení nebo nepovolení operace na základně průniku oprávnění ochraných domén tříd metod, jež vedly k zavolání metody {\tt checkPermission()}. Konkrétně jde o metody nacházející se během volání {\tt checkPermission()} na zásobníku volání (Stack trace). Volala-li tedy metoda {\tt main} třídy {\tt Main} metodu {\tt secured} třídy {\tt Secured}, která následně zavolala metodu {\tt checkPermission()}, musí mít požadované oprávnění přiděleny ochrané domény tříd {\tt Main} i {\tt Secured}, aby toto volání neskončilo vyjímkou vyjadřující zamítnutí provedení operace ze strany Access controlleru. \cite[5.5]{oaks}\cite[6.1]{oaks}


%Access controller je založen na čtyř konceptech: \cite[5]{oaks}
%
%\begin{itemize}
%  \item Zdroje kódu (CodeSource): Objekt představující původ třídy -- adresu URL z které byla získána a certifikáty (elektronické podpisy), kterými byla opatřena %\cite[5.1]{oaks}
%  \item Oprávnění (Permission): Objekt představující operaci o jejíž povolení se rozhoduje, konkrétně se skládá z trojice: typ oprávnění, název zdroje, povolené akce \cite[5.2]{oaks}
%  \item Politiky (Policy): Objekt představující souhrn oprávnění udělených danému zdrojovému kódu \cite[5.3]{oaks}
%  \item Ochranná doména (ProtectionDomain): Objekt představující zdrojové kódy a jejich oprávnění \cite[5.4]{oaks}
%\end{itemize}

%-----------------------------------------------------------------------------
\subsection{Privilegované bloky kódu}\label{privilegovaneBloky}
%-----------------------------------------------------------------------------

Vraťme se nyní k našemu příkladu, kdy chceme různým programům přidělovat oprávnění k jednotlivým databázovým záznamům jako k samostatným zdrojům systému, ale nechceme jim povolit přístup k samotnému databázovému souboru.

Ze způsobu fungování Access controlleru tak jak jsme si jej zatím popsali totiž vyplývá, že aby mohla knihovna zprostředkovávající přístup k databázi přistupovat k databázovému souboru, musí mít oprávnění pracovat s databázovým souborem jak samotná databázová knihovna, tak i každá třída podílející se na jejím volání.

Tento stav je samozřejmě nepřípustný, protože oprávnění na úrovni uživatelského kódu by tímto ztratila význam -- buď by k databázi nemohla přistupovat knihovna volaná kódem, jež má oprávnění jen k některým záznamům, nebo by naopak měl jakýkoli kód, který by potřeboval přistupovat k záznamům v databázi, oprávnění k celému databázovému souboru, čímž by mohl jakákoli omezení na úrovni knihovny zprostředkující přístup k databázi obejít.

Právě tento problém řeší privilegované bloky kódu. Kód v privilegovaném bloku je spuštěn se samostatným zásobníkem volání. Při ověřování oprávnění při přístupu k jakémukoli zdroji tak ověřování skončí u třídy s tímto blokem.

{\bf Část kódu knihovny, jež vložíme do privilegovaného bloku, bude tedy spuštěna s oprávněními této knihovny bez ohledu na oprávnění kódu, jež metodu knihovny zavolal.}

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Příklad použití privilegovaného bloku}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Vykonávání privilegovaného bloku je implementováno jako nativní metoda Access controlleru {\tt doPrivileged()}, které je předán objekt (pod)třídy {\tt PrivilegedAction}, jehož metoda {\tt run()} je spuštěna privilegovaně, tedy bez ohledu na oprávnění třídy volající metodu obsahující vykonání privilegovaného bloku.
Tento příklad ukazuje jednoduchý příklad použití privilegovaného bloku: \cite{refAccessController}

\begin{verbatim}
class DatabazeVSouboru {
  public void provedOperaciNadDatabazi(){
    // Kód zde bude omezen oprávněními volající třídy
    AccessController.doPrivileged(new PrivilegedAction<Void>() {
      public Void run() {
        // Kód zde bude spuštěn nezávisle na oprávnění volající třídy
      }
    }
  }
}
\end{verbatim}

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Příklad s knihovnou pro přístup k databázi}\label{databazeVsouboru}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Tento příklad ukazuje možnou implementaci knihovny pro přístup k databázi, jak byla navržena v kapitole \ref{privilegovaneBloky}.

\begin{verbatim}
class DatabazeVSouboru {
  public Zaznam nactiZaznam(String klic){
    
    // mimo privilegovaný blok ověříme, že volající kód má oprávnění
    AccessController.checkPermission(new ZaznamPermission(klic, "nacteni"));
    
    // s oprávněními knihovny, bez ohledu na oprávnění volajícího kódu...
    return AccessController.doPrivileged(new PrivilegedAction<Zaznam>() {
      public Zaznam run() {
        // ...provedeme požadovanou operaci nad datovými soubory databáze
      }
    });
  }
}
\end{verbatim}

Každá metoda knihovny zpřístupňující záznam v databázi neprve ověří oprávněnost požadavku na přístup k danému záznamu.
Je-li požadavek oprávněný, je v rámci privilegovaného bloku provedena operace nad datovými soubory databáze.
Díky tomu nebudou oprávnění k datovým souborům vyžadována od kódu volajícího tuto metodu, ale pouze od této třídy samotné.

%-----------------------------------------------------------------------------
\subsection{Třídy oprávnění}
%-----------------------------------------------------------------------------

Třída oprávnění představuje typ zdroje, ke kterému lze přidělovat oprávnění.

Třída oprávnění musí být podtřídou třídy {\tt Permission}. Pro snazší implementaci je místo ní možné použít její podtřídu {\tt BasicPermission}.
Aby ji bylo možné použít, musí být definován její konstruktor odpovídající parametrům oprávnění předávaným souborem bezpečnostní politiky a musí být veřejně přístupná -- opatřená specifikátorem přístupu {\tt public}.

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Příklad třídy oprávnění}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Tento příklad ukazuje nejjednodušší způsob vytvoření vlastní třídy oprávnění na oprávnění použitém v příkladu s knihovnou pro přístup k databázi po záznamech v kapitole \ref{databazeVsouboru}.

\begin{verbatim}
public class ZaznamPermission extends java.security.BasicPermission {
    public ZaznamPermission(String name, String actions) {
        super(name, actions);
    }
}
\end{verbatim}

%-----------------------------------------------------------------------------
\subsection{Soubory bezpečnostní politiky}
%-----------------------------------------------------------------------------

Tato kapitola popisuje implementaci bezpečnostních politik za pomoci souborů bezpečnostní politiky.

Soubor bezpečnostní politiky se skládá z deklarací původů tříd a jim přidělovaných oprávnění.
Původ třídy je zde stanoven na základě podpisu JAR archivu z kterého byla třída získána (direktiva {\tt signedBy}), URL kořene systému balíčků tříd, ze kterého byla třída získána (direktiva {\tt codeBase}) nebo obou těchto kritérií najednou. \cite[5.3.1]{oaks}

Syntaxe souboru bezpečnostní politiky, používané standardní implementací bezpečnostní politiky {\tt PolicyFile}, je definována následovně: \cite[5.3.1]{oaks}

\begin{verbatim}
grant [signedBy <podepsaný>] [, codeBase <kořen balíčků>] {
    permission <třída oprávnění> [<název zdroje> [, <povolované operace>]];
    ...
};
\end{verbatim}

Deklarace oprávnění se skládá z názvu třídy oprávnění a parametrů jejího konstruktoru oddělených čárkou.

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Příklad souboru bezpečnostní politiky}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Tento příklad ukazuje jednoduchou bezpečnostní politiku, opět v kontextu příkladu knihovny pro přístup k databázi z kapitoly \ref{databazeVsouboru}.

\begin{verbatim}
grant codeBase "file:/srv/program/" {
  permission ZaznamPermission "Lucka", "nacteni";
};
grant codeBase "file:/srv/knihovna/" {
  permission ZaznamPermission "*", "nacteni";
  permission java.io.FilePermission "/srv/knihovna/data/-","read,write";
};
\end{verbatim}

Programu zde má přiděleno oprávnění k načtení záznamu "Lucka", nemůže ale přistupovat k s samotným databázovým souborů. K těmto má oprávnění přistupovat jen knihovna zpřístupňující tuto databázi. Kvůli způsobu implementace kontroly oprávnění Access controllerem (popsaným v kapitole \ref{implementaceAC}) je nezbytné přidělit knihovně oprávnění ke všem záznamům v databázi, jinak by žádná kontrola oprávněnosti požadavku nemohla skončit pozitivně.

%,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
\subsubsection{Zástupné znaky}
%'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

URL kořene systému balíčků může být ukončeno zástupnými znaky pomlčka ({\tt -}) a hvězdička ({\tt *}).

Zatímco {\tt /*} odpovídá všem souborům v daném adresáři, {\tt /-} odpovídá všem souborům v daném adresáři i jeho podadresářích, rekurzivně.
\cite{jdkdocPolicyFiles}






Rozdíl mezi - a * na konci adresy atd...

Povolované operace jsou definovány za pomoci tří kritérií: \cite{jdkdocPolicyFiles}

\begin{itemize}
  \item {\tt permission\_class\_name}: Typ oprávnění -- název podtřídy třídy {\tt Permission}.
  \item {\tt target\_name}: Název zdroje -- souboru, serveru a portu apod.
  \item {\tt action}: Název povolované operace, např. {\tt read} pro čtení a {\tt delete} pro smazání souboru.
\end{itemize}

Způsob použití bude upřesněn v kapitole Soubory bezpečnostní politiky.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Možnosti správy JVM v prostředí Red Hat JBoss}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Návrh systému}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Závěr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

