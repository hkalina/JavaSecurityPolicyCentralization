%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Jan Kalina <xkalin03@stud.fit.vutbr.cz> 2013
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Bezpečnost v Javě}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\section{Bezpečnost}
%=============================================================================

Protože se tato práce zabývá bezpečností, což je pojem, který lze v různých souvislostech chápat zcela odlišně, je nanejvýš vhodné nejprve specifikovat co termínem bezpečnosti míníme a z kterého pohledu se jí budeme zabývat.

Scott Oaks definuje ve své knize Java Security bezpečnost jako souhrn následujících kritérií: \cite[1.1]{oaks}

\begin{itemize}
  \item Bezpečí vůči zákeřnému software - programy by neměly být schopny poškodit prostředí hostitelského počítače.
  \item Bezpečí vůči Velkému bratru - programům by mělo být bráněno ve šmírování uživatele -- programy by neměly být schopny svévolně číst soukromé informace na počítači na kterém běží, ani na síti ke které je tento počítač připojen.
  \item Autentizace - identita autorů programu by měla být ověřována (typicky pomocí elektronickému podpisu).
  \item Šifrování - data odesílaná a přijímaná programem by měla být šifrována.
  \item Auditovatelnost - potenciálně škodlivé operace by měly být vždy zaznamenávány.
  \item Specifikovanost - program by měla doprovázet specifikace bezpečnostních pravidel, které program dodržuje.
  \item Verifikovanost - pro prováděné operace by měla být stanovena pravidla, proti kterým by měly být verifikovány.
  \item Dbaní na dobré vychování - programům by mělo být bráněno v užívání příliš mnoha systémových prostředků.
\end{itemize}

V souvislosti s víceuživatelskými prostředími se pak pojem bezpečnosti vyskytuje ještě v další rovině, kdy nejde o bezpečí před běžícím programem, ale o způsob jakým může naopak program ověřit, kdo je jeho uživatelem a zdali má právo po něm žádat vykonání operace, o jejíž vykonání žádá.

V této práci se však budeme zabývat bezpečností ve smyslu prvních tří uvedených kritérií, tedy ve smyslu ochrany prostředí a dat hostitele před programy.

%=============================================================================
\section{Java}
%=============================================================================

Programy v jazyce Java bývají překládány do platformě nezávislého a efektivněji než kód v jazyce Java interpretovatelného mezikódu, takzvaného bytekódu.
Bytekód bývá zpravidla interpretován virtuálním strojem Javy (JVM - Java Virtual Machine).
JVM je abstraktní výpočetní stroj. Podobně jako reálné výpočetní stroje má svoji instrukční sadu a paměť se kterou může manipulovat, ale na rozdíl od nich pro něj neexistuje jeho fyzická implementace, pouze emulovaná implementace softwarová.
To znamená že její kód není prováděn nativně hardwarem, ale je interpretován speciálním programem, interpreterem, který je sám zkompilován do nativního kódu dané platformy.
To mimo nezávislosti na platformě přináší také vyšší stupeň abstrakce.

Díky tomu, že programy nepřistupují ani nemohou přistupovat ke zdrojům fyzického stroje přímo, ale pouze zprostředkovaně skrze zdroje virtuální stroje Javy, si není těžké představit, že by použití takovéhoto virtuálního stroje mohlo mít i významný bezpečnostní efekt.
Protože programy v JVM mohou k fyzickým zdrojům počítače (např. k souborům nebo k síti) přistupovat jen skrze JVM, zablokování takového přístupu ze strany JVM není nikterak složité - JVM stačí odmítnout takový požadavek a interpretovaný program nemá možnost JVM obejít.

%=============================================================================
\section{Java Security Manager}
%=============================================================================

Pro rozšiřitelnost omezení kladených na programy běžících na virtuáních strojích Javy nerozhoduje o povolení nebo zablokování operace samotná JVM, ale dotazuje se speciálního objektu třídy {\tt java.lang.SecurityManager}, nebo jeho podtřídy. Podtřída je třída dědící atributy a metody (operace, přijímané zprávy) své nadtřídy a reference na její instanci může být vložena do proměnné určené pro referenci na její nadtřídu. Jakákoli podtřída třídy SecurityManager tedy bude vždy přijímat všechny zprávy, které přijimá třída SecurityManager, přičemž ty které nebude sama implementovat, budou přejaty z její nadtřídy SecurityManager.

Security manager, který JVM použije při svém startu lze ovlivnit skrze konfigurační proměnnou JVM -- {\tt java.security.manager}. Za běhu je možné aktuálně používaný Security manager zjistit voláním {\tt System.getSecurityManager() } a vypnout nebo vyměnit voláním {\tt System.setSecurityManager()}. Volání těchto metod bývá samo chráněno Security managerem, takže nehrozí že by se program neoprávněně zbavil omezení, které na něj uvalil Security manager např. vypnutím Security manageru.

Hodnotu konfigurační proměnné {\tt java.security.manager} po startu JVM je možné nastavit za pomoci k tomu určeného parametru {\tt -D}. Pro spuštění programu s výchozím Security managerem můžeme tedy použít příkaz:

\begin{verbatim}
java -Djava.security.manager=default ProgramABC
\end{verbatim}

Základní možné hodnoty proměnné {\tt java.security.manager} a jim odpovídající třídy objektů security managera popisuje následující tabulka.

\begin{center}
    \begin{tabular}{| l | l |}
    \hline
    Parametr příkazu java & Použitý JSM \\ \hline
    (parametr nepoužit)                                      & {\tt null                      } \\
    {\tt -Djava.security.manager                           } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=default                   } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=java.lang.SecurityManager } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=TestovaciSM               } & {\tt TestovaciSM               } \\
    \hline
    \end{tabular}
\end{center}

Poslední řádek demonstruje použití vlastní třídy objektu security managera. Způsob vytvoření vlastního Security managera bude podrobněji rozebrán v další kapitole. Jestliže je zde uvedena neexistující třída, skončí inicializace JVM vyjímkou a vykonávání programu nebude vůbec zahájeno:

\begin{verbatim}
Error occurred during initialization of VM
java.lang.InternalError: Could not create SecurityManager: neexistujici.SM
    at sun.misc.Launcher.<init>(Launcher.java:106)
    at sun.misc.Launcher.<clinit>(Launcher.java:57)
    at java.lang.ClassLoader.initSystemClassLoader(ClassLoader.java:1486)
    at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1468)
\end{verbatim}

Tím že je zabráněno startu JVM v případě chybné konfigurace Security manageru -- je tedy uplatněn bezpečnostní princip, podle kterého musí systém zůstat bezpečný i v případě poruchového stavu.

%=============================================================================
\section{Implementace vlastního Security managera}
%=============================================================================

V této podkapitole bude vysvětlen způsob vytvoření vlastní třídy Security managera za účelem stanovení vlastní bezpečnostní politiky (v širším slova smyslu). Jak se dozvíme později, vytvoření vlastního Security managera není pro stanovení vlastní bezpečnostní politiky nezbytné, umožňuje ale založit rozhodování o povolení nebo nepovolení operace na takřka jakémkoli algoritmu.

{\tt SecurityManager} (přesněji {\tt java.lang.SecurityManager}) poskytuje rozhraní, skrze které je Java API schopno zjistit, zdali je operace požadovaná uživatelskou aplikací povolena. Algoritmus který Java API používá při provádění potenciálně nebezpečné operace je následující: \cite[4.1.1]{oaks}

\begin{enumerate}
  \item Uživatelská aplikace žádá Java API o provedení dané operace
  \item Java API se dotáže Security manageru zda operaci povolit zavoláním patřičné metody Security manageru.
  \item Nemá-li být operace povolena, vyhodí Security manager vyjímku {\tt SecurityException}, která je předána uživatelské aplikaci
  \item Není-li vyhozena žádná vyjímka, operace se považuje za povolenou a je provedena.
\end{enumerate}

Vlastní Security manager tedy vytvoříme rozšířením třídy {\tt SecurityManager}, přičemž přepíšeme metody rozhodující o povolení akce, kterou chceme povolit, nebo pro kterou chceme stanovit vlastní algoritmus určující zda akci povolit.
Protože standardní Security manager implicitně všechny operace zakazuje, stačí nám implementovat metody autorizující provedení operací, které chceme povolit a operacemi které nikdy povolit chtít nebudeme se nebudeme muset vůbec zabývat.

Příklad níže ukazuje jednoduchý Security manager, který o povolení každé akce rozhodne na základě interakce s uživatelem. Při pokusu programu o provedení bezpečnostně-citlivé operace je na standardní výstup tohoto programu zobrazen dotaz, zda tuto operaci uživatel chce povolit. V případě pozitivní odpovědi je operace povolena, jinak je jejímu provedení vyhozením vyjímky {\tt SecurityException} zabráněno.

\begin{verbatim}
public class TestovaciSM extends SecurityManager {
    @Override
    public void checkPermission(Permission permission) {
        
        System.out.println("Povolit " + permission.toString() + " ?");
        if(!askUser()){ // jestliže uživatel nezvolí "ano"
            throw new SecurityException("Operace byla zakázána uživatelem");
        }
        
    }
}
\end{verbatim}

Libovolný program v Javě pak pod tímto Security managerem spustíme již dříve zmíněným parametrem příkazového řádku:

\begin{verbatim}
java -Djava.security.manager=TestovaciSM HelloWorld
\end{verbatim}

Zkusíme-li spustit sebejednodušší program pod tímto Security managerem, uvidíme že množství kontrolovaných operací je opravdu velké a tvorba Security manageru povolujícího operace vyžadované jednotlivými programy těmto programům by byla možná, ale velice náročná.

%=============================================================================
\section{Access Controller a soubory bezpečnostní politiky}
%=============================================================================

Access controller je mechanismus, který standardní Security manager (od Javy verze 2) využívá pro rozhodnutí, zda operaci požadovanou uživatelským programem povolit či nikoliv. Access controller je přitom schopný seznam povolených operací načítat ze souboru bezpečnostní politiky. Vzniká tak mnohem snazší způsob definice bezpečnostních politik, jimiž budou programy omezeny -- namísto tvorby vlastní třídy Security manageru tak pro stanovení bezpečnostní politiky stačí upravovat obsah konfiguračního souboru používaného Access controllerem pro stanovení bezpečnostní politiky. Tento soubor budeme dále nazývat jen soubor bezpečnostní politiky. \cite[5]{oaks}

Oprávnění jsou programům v rámci bezpečnostní politiky mohou být přidělena na základě tří kritérií: \cite{refPolicyFiles}

\begin{itemize}
  \item {\tt codeBase}: Operaci žádá metoda ze třídy pocházející z URL adresy odpovídající zadané.
  \item {\tt signedBy}: Operaci žádá metoda ze třídy podepsané podpisem odpovídajícím zadanému aliasu.
  \item {\tt principal}: Operaci žádá kód spuštěný uživatelem s daným oprávněním.
\end{itemize}

Povolované operace jsou definovány za pomoci tří kritérií: \cite{jdkdocPolicyFiles}

\begin{itemize}
  \item {\tt permission\_class\_name}: Typ oprávnění -- název podtřídy třídy {\tt Permission}.
  \item {\tt target\_name}: Název zdroje -- souboru, serveru a portu apod.
  \item {\tt action}: Název povolované operace, např. {\tt read} pro čtení a {\tt delete} pro smazání souboru.
\end{itemize}

Způsob použití bude upřesněn v kapitole Soubory bezpečnostní politiky.

%-----------------------------------------------------------------------------
\subsection{Access Controller}
%-----------------------------------------------------------------------------

Access controller je třídou {\tt java.security.AccessController} a voláním jeho statických metod na něj standardní security manager deleguje rozhodnutí o legálnosti provedení potenciálně nežádoucí operace uživatelského programu. Konkrétně kontrolu obstarává metoda {\tt checkPermission(Permission)}, která v případě neoprávněnosti požadavku na provedení operace způsobí vyhození vyjímky {\tt AccessControlException}. Jejím vstupem je objekt třídy {\tt Permission}, která reprezentuje oprávnění, jehož vlastnictví je testováno. \cite[5.5]{oaks}

Následující příklad ukazuje způsob, jakým se lze Access controlleru dotázat na oprávněnost požadavku: \cite[5.5]{oaks}

\begin{verbatim}
try {
    // má tento program oprávnění připojit se na lokální port 80?
    AccessController.checkPermission(
        new SocketPermission("localhost:80", "connect")
    );
    System.out.println("Program má oprávnění připojit se na port");
} catch (AccessControlException ace) {
    System.out.println("Program nemá oprávnění připojit se na port");
}
\end{verbatim}

Access controller je založen na čtyř konceptech: \cite[5]{oaks}

\begin{itemize}
  \item Zdroje kódu (CodeSource): Objekt představující původ třídy -- adresu URL z které byla získána a certifikáty (elektronické podpisy), kterými byla opatřena \cite[5.1]{oaks}
  \item Oprávnění (Permission): Objekt představující operaci o jejíž povolení se rozhoduje, konkrétně se skládá z trojice: typ oprávnění, název zdroje, povolené akce \cite[5.2]{oaks}
  \item Politiky (Policy): Objekt představující souhrn oprávnění udělených danému zdrojovému kódu \cite[5.3]{oaks}
  \item Ochranná doména (ProtectionDomain): Objekt představující zdrojové kódy a jejich oprávnění \cite[5.4]{oaks}
\end{itemize}

%-----------------------------------------------------------------------------
\subsection{Soubory bezpečnostní politiky}
%-----------------------------------------------------------------------------



%=============================================================================
\section{Zavaděče tříd}
%=============================================================================

Zavaděč (classloader) je objekt odpovědný za načítání tříd a rozhraní v Javě. Na základně binárního názvu třídy (tedy názvu používaného v bytekódu, např. {\tt java.lang.String} nebo {\tt java.security.KeyStore\$Builder\$FileBuilder\$1}) se pokusí vyhledat a načíst třídu daného názvu. \cite{refClassLoader}

Třída každého zavaděče musí být podtřídou třídy {\tt java.lang.ClassLoader} a musí implementovat metodu {\tt findClass()}, která provádí právě samotné vyhledání třídy podle názvu. Jejím výstupem je objekt třídy {\tt Class} představující samotnou třídu. K vytvoření objektu třídy Class metoda obvykle využívá zděděné metody ({\tt defineClass()}), které kromě názvu třídy a bytů samotných dat třídy předává také informace o původu a z něj vyplývajících oprávnění zapouzdřené v objektu tzv. ochrané domény ({\tt ProtectionDomain}). \cite{refClassLoader}

Při programování běžných aplikací můžeme na objekty třídy {\tt Class} narazit například při snaze získat název třídy neznámého objektu jako řetězec za běhu aplikace:

\begin{verbatim}
String nazev = x.getClass().getName(); // getClass() vrací objekt Class
\end{verbatim}

Z hlediska bezpečnosti pro nás jsou ale classloadery zajímavé hlavně tím, že právě ony poskytují informaci o původu načtené třídy. O povolení operace totiž rozhodujeme zpravidla právě na základě původu třídy jež ji volá.

Původ může být určen dvěma způsoby -- na základě adresy souboru, z kterého byla třída načtena, nebo na základě elektronického podpisu, kterým byla třída při svém načítání opatřena.

Původ třídy, zmíněný výše jako součást ochranné domény, je stanoven třídou ({\tt CodeSource}), jejíž první částí je URL adresa, ze které byla třída získána, a druhou částí je buď pole certifikátů ({\tt Certificate}) kterými byla třída podepsána nebo pole podepsaných autorů ({\tt CodeSigner}). \cite{refClassLoader}

%-----------------------------------------------------------------------------
\subsection{Interní zavaděč tříd}
%-----------------------------------------------------------------------------

Protože samotné zavaděče tříd jsou samy třídami v Javě, vzniká problém jak načíst třídu samotného zavaděče tříd. K podobným účelům se používá tzv. interní zavaděč tříd. Interní zavaděč je součástí JVM, je napsán převážně v nativním kódu a k načítání tříd využívá nativní metody pro přístup k souborovému systému operačního systému. Interní zavaděč načítá třídy ze souborů, jejiž adresu odvozuje z názvu třídy, balíčku a proměnné prostředí CLASSPATH. \cite[3.2.1]{oaks}

Je-li tedy JVM spuštěna následujícím příkazem:

\begin{verbatim}
java -classpath /srv/classes muj.program.Test
\end{verbatim}

Bude spuštěna metoda {\tt main()} třídy {\tt Test} v souboru:

\begin{verbatim}
/srv/classes/muj/program/Test.class
\end{verbatim}

O třídách načtených interním zavaděčem se často mluví jako o třídách bez zavaděče, protože jejich objekt {\tt Class} má referenci na zavaděč nastavenu na {\tt null}. \cite[3.2.1]{oaks}

Interní zavaděč je v současnosti používán k načítání jen nejzákladnějších tříd, zejména tříd Java API, tedy tříd používajících součásti napsané v nativním kódu. Ostatní třídy z {\tt CLASSPATH} jsou obvykle načítány Zavaděčem tříd z URL.

%-----------------------------------------------------------------------------
\subsection{Zavaděč tříd z URL}
%-----------------------------------------------------------------------------

Zavaděč tříd z URL ({\tt URLClassLoader}) hledá třídy na URL adresách určených polem objektů {\tt URL} předaných jeho kontruktoru. Je jedním z nejpoužívanějších zavaděčů tříd v Javě -- používá se i k vyhledávání méně základních tříd z {\tt CLASSPATH} a dokáže třídy načítat nejen z adresářů, ale i z JAR archivů, je-li jako adresa uvedena adresa JAR archivu. \cite[3.2.5]{oaks}

\begin{verbatim}
URLClassLoader urlClassLoader = new URLClassLoader(new URL[]{
    new URL("http://server/directory/"),
    new URL("file:/srv/classes/")
}, parentClassloader);
\end{verbatim}




\begin{verbatim}
http://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html
http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html
http://docs.oracle.com/javase/jndi/tutorial/beyond/misc/classloader.html
http://www.linuxsoft.cz/article.php?id_article=1123
\end{verbatim}












%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Závěr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

