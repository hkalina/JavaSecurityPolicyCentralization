%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Jan Kalina <xkalin03@stud.fit.vutbr.cz> 2013
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Teoretický úvod}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%=============================================================================
\section{Bezpečnost}
%=============================================================================

Protože se tato práce zabývá bezpečností, což je pojem, který lze v různých souvislostech chápat zcela odlišně, je nanejvýš vhodné nejprve specifikovat co termínem bezpečnosti míníme a z kterého pohledu se jí budeme zabývat.

Scott Oaks definuje ve své knize Java Security bezpečnost jako souhrn následujících kritérií: \cite[1.1]{oaks}

\begin{itemize}
  \item Bezpečí vůči zákeřnému software - programy by neměly být schopny poškodit prostředí hostitelského počítače.
  \item Bezpečí vůči Velkému bratru - programům by mělo být bráněno ve šmírování uživatele -- programy by neměly být schopny svévolně číst soukromé informace na počítači na kterém běží, ani na síti ke které je tento počítač připojen.
  \item Autentizace - identita autorů programu by měla být ověřována (typicky elektronickým podpisem).
  \item Šifrování - data odesílaná a přijímaná programem by měla být šifrována.
  \item Auditovatelnost - potenciálně škodlivé operace by měly být vždy zaznamenávány.
  \item Specifikovanost - program by měla doprovázet specifikace bezpečnostních pravidel, které program dodržuje.
  \item Verifikovanost - pro prováděné operace by měla být stanovena pravidla, proti kterým by měly být verifikovány.
  \item Dbaní na dobré vychování - programům by mělo být bráněno v užívání příliš mnoha systémových prostředků.
\end{itemize}

V souvislosti s víceuživatelskými prostředími se pak pojem bezpečnosti vyskytuje ještě v další rovině, kdy nejde o bezpečí před běžícím programem, ale o způsob jakým může naopak program ověřit, kdo je jeho uživatelem a zdali má právo po něm žádat vykonání operace, o jejíž vykonání žádá.

V této práci se však budeme zabývat bezpečností ve smyslu prvních tří uvedených kritérií, tedy ve smyslu ochrany prostředí a dat hostitele před programy.

%=============================================================================
\section{Java}
%=============================================================================

Programy v jazyce Java bývají překládány do platformě nezávislého a efektivněji než kód v jazyce Java interpretovatelného mezikódu, takzvaného bytekódu.
Bytekód bývá zpravidla interpretován virtuálním strojem Javy (JVM - Java Virtual Machine).
JVM je abstraktní výpočetní stroj, podobně jako například Turingův stroj.
Stejně jako reálný výpočetní stroj má svoji instrukční sadu a paměť se kterou může manipulovat, ale na rozdíl od něj pro něj neexistuje jeho fyzická implementace, pouze emulovaná implementace softwarová.
To znamená že její kód není prováděn nativně hardwarem, ale je interpretován speciálním programem, interpreterem, který sám zkompilován do nativního kódu dané platformy.
To mimo nezávislosti na platformě přináší také vyšší stupeň abstrakce.

Díky tomu, že programy nepřistupují ani nemohou přistupovat ke zdrojům fyzického stroje přímo, ale pouze zprostředkovaně skrze zdroje virtuální stroje Javy, si není těžké představit, že by použití takovéhoto virtuálního stroje mohlo mít i významný bezpečnostní efekt.
Protože programy v JVM mohou k fyzickým zdrojům počítače (např. k souborům nebo k síti) přistupovat jen skrze JVM, zablokování takového přístupu ze strany JVM není nikterak složité - JVM stačí odmítnout takový požadavek a interpretovaný program nemá možnost JVM obejít.

%=============================================================================
\section{Java Security Manager}
%=============================================================================

Pro maximální rozšiřitelnost omezení kladených na programy běžících na virtuáních strojích Javy nerozhoduje o povolení nebo zablokování operace samotná JVM, ale dotazuje se speciálního objektu třídy {\tt java.lang.SecurityManager}, nebo jeho podtřídy. Podtřída je třída dědící atributy a metody (operace, přijímané zprávy) své nadtřídy a reference na její instanci může být vložena do proměnné určené pro referenci na její nadtřídu. Jakákoli podtřída třídy SecurityManager tedy bude vždy přijímat všechny zprávy, které přijimá třída SecurityManager, přičemž ty které nebude sama implementovat, budou přejaty z její nadtřídy SecurityManager.

Security manager, který JVM použije při svém startu lze ovlivnit skrze konfigurační proměnnou JVM -- {\tt java.security.manager}. Za běhu je možné aktuálně používaný Security manager zjistit voláním {\tt System.getSecurityManager() } a vypnout nebo vyměnit voláním {\tt System.setSecurityManager()}. Volání těchto metod bývá samo chráněno Security managerem, takže nehrozí že by se program neoprávněně zbavil omezení, které na něj uvalil Security manager např. vypnutím Security manageru.

Hodnotu konfigurační proměnné {\tt java.security.manager} po startu JVM je možné nastavit za pomoci k tomu určeného parametru {\tt -D}. Pro spuštění programu s výchozím Security managerem můžeme tedy použít příkaz:

\begin{verbatim}
java -Djava.security.manager=default ProgramABC
\end{verbatim}

Základní možné hodnoty proměnné {\tt java.security.manager} a jim odpovídající třídy objektů security managera popisuje následující tabulka.

\begin{center}
    \begin{tabular}{| l | l |}
    \hline
    Parametr příkazu java & Použitý JSM \\ \hline
    (parametr nepoužit)                                      & {\tt null                      } \\
    {\tt -Djava.security.manager                           } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=default                   } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=java.lang.SecurityManager } & {\tt java.lang.SecurityManager } \\
    {\tt -Djava.security.manager=TestovaciSM               } & {\tt TestovaciSM               } \\
    \hline
    \end{tabular}
\end{center}

Poslední řádek demonstruje použití vlastní třídy objektu security managera. Způsob vytvoření vlastního Security managera bude podrobněji rozebrán v další kapitole. Jestliže je zde uvedena neexistující třída, skončí inicializace JVM vyjímkou a vykonávání programu nebude vůbec zahájeno:

\begin{verbatim}
Error occurred during initialization of VM
java.lang.InternalError: Could not create SecurityManager: neexistujici.SM
    at sun.misc.Launcher.<init>(Launcher.java:106)
    at sun.misc.Launcher.<clinit>(Launcher.java:57)
    at java.lang.ClassLoader.initSystemClassLoader(ClassLoader.java:1486)
    at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1468)
\end{verbatim}

Tím že je zabráněno startu JVM v případě chybné konfigurace Security manageru -- je tedy uplatněn bezpečnostní princip, podle kterého musí systém zůstat bezpečný i v případě poruchového stavu.

%=============================================================================
\section{Implementace vlastního Security managera}
%=============================================================================

V této podkapitole bude vysvětlen způsob vytvoření vlastní třídy Security managera za účelem stanovení vlastní bezpečnostní politiky (v širším slova smyslu). Jak se dozvíme později, vytvoření vlastního Security managera není pro stanovení vlastní bezpečnostní politiky nezbytné, umožňuje ale založit rozhodování o povolení nebo nepovolení operace na takřka jakémkoli algoritmu.

{\tt SecurityManager} (přesněji {\tt java.lang.SecurityManager}) poskytuje rozhraní, skrze které je Java API schopno zjistit, zdali je operace požadovaná uživatelskou aplikací povolena. Algoritmus který Java API používá při provádění potenciálně nebezpečné operace je následující: \cite[4.1.1]{oaks}

\begin{enumerate}
  \item Uživatelská aplikace žádá Java API o provedení dané operace
  \item Java API se dotáže Security manageru zda operaci povolit zavoláním patřičné metody Security manageru.
  \item Nemá-li být operace povolena, vyhodí Security manager vyjímku {\tt SecurityException}, která je předána uživatelské aplikaci
  \item Není-li vyhozena žádná vyjímka, operace se považuje za povolenou a je provedena.
\end{enumerate}

Vlastní Security manager tedy vytvoříme rozšířením třídy {\tt SecurityManager}, přičemž přepíšeme metody rozhodující o povolení akce, kterou chceme povolit, nebo pro kterou chceme stanovit vlastní algoritmus určující zda akci povolit.
Protože standardní Security manager implicitně všechny operace zakazuje, stačí nám implementovat metody autorizující provedení operací, které chceme povolit a operacemi které nikdy povolit chtít nebudeme se nebudeme muset vůbec zabývat.

Příklad níže ukazuje jednoduchý Security manager, který o povolení každé akce rozhodne na základě interakce s uživatelem. Při pokusu programu o provedení bezpečnostně-citlivé operace je na standardní výstup tohoto programu zobrazen dotaz, zda tuto operaci uživatel chce povolit. V případě pozitivní odpovědi je operace povolena, jinak je jejímu provedení vyhozením vyjímky {\tt SecurityException} zabráněno.

\begin{verbatim}
public class TestovaciSM extends SecurityManager {
    @Override
    public void checkPermission(Permission permission) {
        
        System.out.println("Povolit " + permission.toString() + " ?");
        if(!askUser()){ // jestliže uživatel nezvolí "ano"
            throw new SecurityException("Operace byla zakázána uživatelem");
        }
        
    }
}
\end{verbatim}

Tento příklad je samozřejmě pouze demonstrativní, zbytečně obtěžuje uživatele požadováním povolení velkého množství operací, které jsou nezbytné pro spuštění sebejednodušší aplikace. Po rozšíření o ukládání povolených operací by ale mohl najít praktické uplatnění i podobně jednoduchý Security manager. Po rozšíření o grafické uživatelské rozhraní by mohl fungovat podobně jako interaktivní firewall.

%=============================================================================
\section{Zavaděče tříd}
%=============================================================================

Zavaděč (classloader) je objekt odpovědný za načítání tříd a rozhraní v Javě. Na základně binárního názvu třídy (tedy názvu používaného v bytekódu, např. {\tt java.lang.String} nebo {\tt java.security.KeyStore\$Builder\$FileBuilder\$1}) se pokusí vyhledat a načíst třídu daného názvu. \ref{refClassLoader}

Třída každého zavaděče musí být podtřídou třídy {\tt java.lang.ClassLoader} a musí implementovat metodu {\tt findClass()}, která provádí právě samotné vyhledání třídy podle názvu. Jejím výstupem je objekt třídy {\tt Class} představující samotnou třídu. K vytvoření objektu třídy Class metoda obvykle využívá zděděné metody ({\tt defineClass()}), které kromě názvu třídy a bytů samotných dat třídy předává také informace o původu a z něj vyplývajících oprávnění zapouzdřené v objektu tzv. ochrané domény ({\tt ProtectionDomain}). \ref{refClassLoader}

Při programování běžných aplikací můžeme na objekty třídy {\tt Class} narazit například při snaze získat název třídy neznámého objektu jako řetězec za běhu aplikace:

\begin{verbatim}
String nazev = x.getClass().getName(); // getClass() vrací objekt Class
\end{verbatim}

Z hlediska bezpečnosti pro nás jsou ale classloadery zajímavé hlavně tím, že právě ony poskytují informaci o původu načtené třídy. O povolení operace totiž rozhodujeme zpravidla právě na základě původu třídy jež ji volá.

Původ může být určen dvěma způsoby -- na základě adresy souboru, z kterého byla třída načtena, nebo na základě elektronického podpisu, kterým byla třída při svém načítání opatřena.

Původ třídy, zmíněný výše jako součást ochranné domény, je stanoven třídou ({\tt CodeSource}), jejíž první částí je URL adresa, ze které byla třída získána, a druhou částí je buď pole certifikátů ({\tt Certificate}) kterými byla třída podepsána nebo pole podepsaných ({\tt CodeSigner}). \ref{refClassLoader}





\begin{verbatim}
http://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html
http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html
http://docs.oracle.com/javase/jndi/tutorial/beyond/misc/classloader.html
http://www.linuxsoft.cz/article.php?id_article=1123
\end{verbatim}












%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Závěr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

